{"ast":null,"code":"var _class;\nimport { Pathfinder } from './pathfinder';\nimport * as i0 from \"@angular/core\";\nexport class AStarService extends Pathfinder {\n  constructor() {\n    super(...arguments);\n    this.doIteration = () => {\n      let [index, closestNode] = this.getClosestNode();\n      this.currentNode = closestNode;\n      // algorithm will do iteration regardless of if it's done or not\n      this.visitNode(closestNode);\n      this.unvisitedNodes.splice(index, 1);\n      this.iterationCount += 1;\n    };\n    // get node of least heuristic distance\n    this.getClosestNode = () => {\n      let closestNode = this.unvisitedNodes[0];\n      let closestNodeIndex = undefined;\n      for (let [index, node] of this.unvisitedNodes.entries()) {\n        if (node.heuristicDistance < closestNode.heuristicDistance) {\n          closestNode = node;\n          closestNodeIndex = index;\n        }\n      }\n      return [closestNodeIndex, closestNode];\n    };\n    // add all adjacent nodes that haven't been visited to unvisitedNodes list\n    // assign adjacent nodes distances and set current node to visited \n    this.visitNode = nodeToVisit => {\n      let unvisitedNeighbours = this.getUnvisitedNeighbours(nodeToVisit);\n      for (let {\n        node: neighbour,\n        relativeDistance\n      } of unvisitedNeighbours) {\n        let potentialDistance = nodeToVisit.pathDistance + relativeDistance + neighbour.weight;\n        let manhattanDistance = Math.abs(neighbour.xPosition - this.endingNode.xPosition);\n        +Math.abs(neighbour.yPosition - this.endingNode.yPosition);\n        // let euclideanDistance = Math.sqrt((neighbour.xPosition - this.endingNode.xPosition) ** 2 +\n        // (neighbour.yPosition - this.endingNode.yPosition) ** 2);\n        if (neighbour.pathDistance > potentialDistance) {\n          neighbour.pathDistance = potentialDistance;\n          neighbour.heuristicDistance = potentialDistance + manhattanDistance * this.heuristicWeight;\n          neighbour.parent = nodeToVisit;\n          if (!this.unvisitedNodes.includes(neighbour)) {\n            this.unvisitedNodes.push(neighbour);\n            neighbour.isProspected = true;\n          }\n        }\n      }\n      nodeToVisit.isVisited = true;\n    };\n  }\n}\n_class = AStarService;\n_class.ɵfac = /*@__PURE__*/function () {\n  let ɵAStarService_BaseFactory;\n  return function AStarService_Factory(t) {\n    return (ɵAStarService_BaseFactory || (ɵAStarService_BaseFactory = i0.ɵɵgetInheritedFactory(_class)))(t || _class);\n  };\n}();\n_class.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n  token: _class,\n  factory: _class.ɵfac,\n  providedIn: 'root'\n});","map":{"version":3,"names":["Pathfinder","AStarService","constructor","doIteration","index","closestNode","getClosestNode","currentNode","visitNode","unvisitedNodes","splice","iterationCount","closestNodeIndex","undefined","node","entries","heuristicDistance","nodeToVisit","unvisitedNeighbours","getUnvisitedNeighbours","neighbour","relativeDistance","potentialDistance","pathDistance","weight","manhattanDistance","Math","abs","xPosition","endingNode","yPosition","heuristicWeight","parent","includes","push","isProspected","isVisited","t","factory","ɵfac","providedIn"],"sources":["C:\\Users\\Miguel\\Desktop\\algorithm-visualizer-master\\src\\app\\node-map\\services\\algorithms\\a-star.service.ts"],"sourcesContent":["import { Injectable } from '@angular/core';\nimport { Node } from 'src/app/node/node';\nimport { Pathfinder } from './pathfinder';\n\n@Injectable({\n  providedIn: 'root'\n})\nexport class AStarService extends Pathfinder{\n\n  override doIteration = (): void => {\n    let [index, closestNode] = this.getClosestNode();\n    this.currentNode = closestNode;\n\n    // algorithm will do iteration regardless of if it's done or not\n    this.visitNode(closestNode);\n    this.unvisitedNodes.splice(index, 1);\n\n    this.iterationCount += 1;\n  }\n\n  // get node of least heuristic distance\n  getClosestNode = () => {\n    let closestNode = this.unvisitedNodes[0];\n    let closestNodeIndex = undefined;\n\n    for (let [index, node] of this.unvisitedNodes.entries()) {\n      if (node.heuristicDistance < closestNode.heuristicDistance) {\n          closestNode = node;\n          closestNodeIndex = index;\n      }\n    }\n\n    return [closestNodeIndex, closestNode];\n  }\n\n  // add all adjacent nodes that haven't been visited to unvisitedNodes list\n  // assign adjacent nodes distances and set current node to visited \n  visitNode = (nodeToVisit: Node) => {\n    let unvisitedNeighbours = this.getUnvisitedNeighbours(nodeToVisit);\n\n    for (let { node: neighbour, relativeDistance } of unvisitedNeighbours) {\n      let potentialDistance = nodeToVisit.pathDistance + relativeDistance + neighbour.weight;\n\n      let manhattanDistance = Math.abs(neighbour.xPosition - this.endingNode.xPosition);\n       + Math.abs(neighbour.yPosition - this.endingNode.yPosition);\n      \n      // let euclideanDistance = Math.sqrt((neighbour.xPosition - this.endingNode.xPosition) ** 2 +\n      // (neighbour.yPosition - this.endingNode.yPosition) ** 2);\n\n      if (neighbour.pathDistance > potentialDistance) {\n        neighbour.pathDistance = potentialDistance;\n        neighbour.heuristicDistance = potentialDistance + (manhattanDistance * this.heuristicWeight);\n        neighbour.parent = nodeToVisit;\n\n        if (!this.unvisitedNodes.includes(neighbour)) {\n          this.unvisitedNodes.push(neighbour);\n          neighbour.isProspected = true;\n        }\n      }\n    }\n\n    nodeToVisit.isVisited = true;\n  }\n}\n"],"mappings":";AAEA,SAASA,UAAU,QAAQ,cAAc;;AAKzC,OAAM,MAAOC,YAAa,SAAQD,UAAU;EAH5CE,YAAA;;IAKW,KAAAC,WAAW,GAAG,MAAW;MAChC,IAAI,CAACC,KAAK,EAAEC,WAAW,CAAC,GAAG,IAAI,CAACC,cAAc,EAAE;MAChD,IAAI,CAACC,WAAW,GAAGF,WAAW;MAE9B;MACA,IAAI,CAACG,SAAS,CAACH,WAAW,CAAC;MAC3B,IAAI,CAACI,cAAc,CAACC,MAAM,CAACN,KAAK,EAAE,CAAC,CAAC;MAEpC,IAAI,CAACO,cAAc,IAAI,CAAC;IAC1B,CAAC;IAED;IACA,KAAAL,cAAc,GAAG,MAAK;MACpB,IAAID,WAAW,GAAG,IAAI,CAACI,cAAc,CAAC,CAAC,CAAC;MACxC,IAAIG,gBAAgB,GAAGC,SAAS;MAEhC,KAAK,IAAI,CAACT,KAAK,EAAEU,IAAI,CAAC,IAAI,IAAI,CAACL,cAAc,CAACM,OAAO,EAAE,EAAE;QACvD,IAAID,IAAI,CAACE,iBAAiB,GAAGX,WAAW,CAACW,iBAAiB,EAAE;UACxDX,WAAW,GAAGS,IAAI;UAClBF,gBAAgB,GAAGR,KAAK;;;MAI9B,OAAO,CAACQ,gBAAgB,EAAEP,WAAW,CAAC;IACxC,CAAC;IAED;IACA;IACA,KAAAG,SAAS,GAAIS,WAAiB,IAAI;MAChC,IAAIC,mBAAmB,GAAG,IAAI,CAACC,sBAAsB,CAACF,WAAW,CAAC;MAElE,KAAK,IAAI;QAAEH,IAAI,EAAEM,SAAS;QAAEC;MAAgB,CAAE,IAAIH,mBAAmB,EAAE;QACrE,IAAII,iBAAiB,GAAGL,WAAW,CAACM,YAAY,GAAGF,gBAAgB,GAAGD,SAAS,CAACI,MAAM;QAEtF,IAAIC,iBAAiB,GAAGC,IAAI,CAACC,GAAG,CAACP,SAAS,CAACQ,SAAS,GAAG,IAAI,CAACC,UAAU,CAACD,SAAS,CAAC;QAChF,CAAEF,IAAI,CAACC,GAAG,CAACP,SAAS,CAACU,SAAS,GAAG,IAAI,CAACD,UAAU,CAACC,SAAS,CAAC;QAE5D;QACA;QAEA,IAAIV,SAAS,CAACG,YAAY,GAAGD,iBAAiB,EAAE;UAC9CF,SAAS,CAACG,YAAY,GAAGD,iBAAiB;UAC1CF,SAAS,CAACJ,iBAAiB,GAAGM,iBAAiB,GAAIG,iBAAiB,GAAG,IAAI,CAACM,eAAgB;UAC5FX,SAAS,CAACY,MAAM,GAAGf,WAAW;UAE9B,IAAI,CAAC,IAAI,CAACR,cAAc,CAACwB,QAAQ,CAACb,SAAS,CAAC,EAAE;YAC5C,IAAI,CAACX,cAAc,CAACyB,IAAI,CAACd,SAAS,CAAC;YACnCA,SAAS,CAACe,YAAY,GAAG,IAAI;;;;MAKnClB,WAAW,CAACmB,SAAS,GAAG,IAAI;IAC9B,CAAC;;;SAvDUnC,YAAa;;;;+FAAbA,MAAY,IAAAoC,CAAA,IAAZpC,MAAY;EAAA;AAAA;;SAAZA,MAAY;EAAAqC,OAAA,EAAZrC,MAAY,CAAAsC,IAAA;EAAAC,UAAA,EAFX;AAAM"},"metadata":{},"sourceType":"module","externalDependencies":[]}