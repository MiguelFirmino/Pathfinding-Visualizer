{"ast":null,"code":"// base class for all pathfinding algorithms\nexport class Pathfinder {\n  constructor() {\n    this.iterationCount = 0;\n    this.setAlgorithmValues = (start, end) => {\n      this.startingNode = start;\n      this.startingNode.pathDistance = 0;\n      this.endingNode = end;\n      this.unvisitedNodes = [this.startingNode];\n      this.currentNode = undefined;\n      this.iterationCount = 0;\n    };\n    this.getUnvisitedNeighbours = node => {\n      let nodeNeighbours = node.neighbours;\n      return [...nodeNeighbours.filter(neighbour => !neighbour.node.isBlocked && !neighbour.node.isVisited)];\n    };\n    this.checkIfDone = () => {\n      if (this.currentNode === this.endingNode) {\n        return {\n          isDone: true,\n          reason: 'reached end'\n        };\n      } else if (this.unvisitedNodes.length == 0) {\n        return {\n          isDone: true,\n          reason: 'no solution'\n        };\n      } else {\n        return {\n          isDone: false\n        };\n      }\n    };\n    this.doCompleteCycle = () => {\n      while (!this.checkIfDone().isDone) {\n        this.doIteration();\n      }\n      return this.currentNode;\n    };\n    this.tracePath = nodeToTrace => {\n      let pathNodes = [];\n      while (nodeToTrace.parent) {\n        pathNodes.push(nodeToTrace);\n        nodeToTrace = nodeToTrace.parent;\n      }\n      return pathNodes;\n    };\n  }\n}","map":{"version":3,"names":["Pathfinder","constructor","iterationCount","setAlgorithmValues","start","end","startingNode","pathDistance","endingNode","unvisitedNodes","currentNode","undefined","getUnvisitedNeighbours","node","nodeNeighbours","neighbours","filter","neighbour","isBlocked","isVisited","checkIfDone","isDone","reason","length","doCompleteCycle","doIteration","tracePath","nodeToTrace","pathNodes","parent","push"],"sources":["C:\\Users\\Miguel\\Desktop\\algorithm-visualizer\\src\\app\\node-map\\services\\algorithms\\pathfinder.ts"],"sourcesContent":["import { Node } from 'src/app/node/node';\r\n\r\n// base class for all pathfinding algorithms\r\nexport class Pathfinder {\r\n  startingNode: Node;\r\n  endingNode: Node;\r\n  unvisitedNodes: Node[];\r\n  currentNode: Node;\r\n  public iterationCount: number = 0;\r\n  doIteration: any;\r\n\r\n  setAlgorithmValues = (start: Node, end: Node) => {\r\n    this.startingNode = start;\r\n    this.startingNode.pathDistance = 0;\r\n    this.endingNode = end;\r\n    this.unvisitedNodes = [this.startingNode];\r\n    this.currentNode = undefined;\r\n    this.iterationCount = 0;\r\n  };\r\n\r\n  getUnvisitedNeighbours = (node: Node) => {\r\n    let nodeNeighbours = node.neighbours\r\n\r\n    return [...nodeNeighbours.filter((neighbour) => !neighbour.node.isBlocked && !neighbour.node.isVisited)];\r\n  };\r\n\r\n  checkIfDone = (): { isDone: boolean, reason?: string } => {\r\n    if (this.currentNode === this.endingNode) {\r\n      return { isDone: true, reason: 'reached end' };\r\n    } else if (this.unvisitedNodes.length == 0) {\r\n      return { isDone: true, reason: 'no solution' };\r\n    } else {\r\n      return { isDone: false };\r\n    }\r\n  };\r\n\r\n  doCompleteCycle = () => {\r\n    while (!this.checkIfDone().isDone) {\r\n      this.doIteration();\r\n    }\r\n\r\n    return this.currentNode;\r\n  }\r\n\r\n  tracePath = (nodeToTrace: Node) => {\r\n    let pathNodes = [];\r\n\r\n    while (nodeToTrace.parent) {\r\n      pathNodes.push(nodeToTrace);\r\n      nodeToTrace = nodeToTrace.parent;\r\n    }\r\n\r\n    return pathNodes;\r\n  }\r\n}\r\n"],"mappings":"AAEA;AACA,OAAM,MAAOA,UAAU;EAAvBC,YAAA;IAKS,KAAAC,cAAc,GAAW,CAAC;IAGjC,KAAAC,kBAAkB,GAAG,CAACC,KAAW,EAAEC,GAAS,KAAI;MAC9C,IAAI,CAACC,YAAY,GAAGF,KAAK;MACzB,IAAI,CAACE,YAAY,CAACC,YAAY,GAAG,CAAC;MAClC,IAAI,CAACC,UAAU,GAAGH,GAAG;MACrB,IAAI,CAACI,cAAc,GAAG,CAAC,IAAI,CAACH,YAAY,CAAC;MACzC,IAAI,CAACI,WAAW,GAAGC,SAAS;MAC5B,IAAI,CAACT,cAAc,GAAG,CAAC;IACzB,CAAC;IAED,KAAAU,sBAAsB,GAAIC,IAAU,IAAI;MACtC,IAAIC,cAAc,GAAGD,IAAI,CAACE,UAAU;MAEpC,OAAO,CAAC,GAAGD,cAAc,CAACE,MAAM,CAAEC,SAAS,IAAK,CAACA,SAAS,CAACJ,IAAI,CAACK,SAAS,IAAI,CAACD,SAAS,CAACJ,IAAI,CAACM,SAAS,CAAC,CAAC;IAC1G,CAAC;IAED,KAAAC,WAAW,GAAG,MAA2C;MACvD,IAAI,IAAI,CAACV,WAAW,KAAK,IAAI,CAACF,UAAU,EAAE;QACxC,OAAO;UAAEa,MAAM,EAAE,IAAI;UAAEC,MAAM,EAAE;QAAa,CAAE;OAC/C,MAAM,IAAI,IAAI,CAACb,cAAc,CAACc,MAAM,IAAI,CAAC,EAAE;QAC1C,OAAO;UAAEF,MAAM,EAAE,IAAI;UAAEC,MAAM,EAAE;QAAa,CAAE;OAC/C,MAAM;QACL,OAAO;UAAED,MAAM,EAAE;QAAK,CAAE;;IAE5B,CAAC;IAED,KAAAG,eAAe,GAAG,MAAK;MACrB,OAAO,CAAC,IAAI,CAACJ,WAAW,EAAE,CAACC,MAAM,EAAE;QACjC,IAAI,CAACI,WAAW,EAAE;;MAGpB,OAAO,IAAI,CAACf,WAAW;IACzB,CAAC;IAED,KAAAgB,SAAS,GAAIC,WAAiB,IAAI;MAChC,IAAIC,SAAS,GAAG,EAAE;MAElB,OAAOD,WAAW,CAACE,MAAM,EAAE;QACzBD,SAAS,CAACE,IAAI,CAACH,WAAW,CAAC;QAC3BA,WAAW,GAAGA,WAAW,CAACE,MAAM;;MAGlC,OAAOD,SAAS;IAClB,CAAC;EACH"},"metadata":{},"sourceType":"module","externalDependencies":[]}