{"ast":null,"code":"import * as i0 from \"@angular/core\";\nexport let NodeMapService = /*#__PURE__*/(() => {\n  var _class;\n  class NodeMapService {\n    constructor() {\n      this.generateMap = (mapWidth, mapHeight) => {\n        let map = [];\n        // generate nodes\n        for (let i = 0; i < mapHeight; i++) {\n          map.push(...this.generateRow(mapWidth, i));\n        }\n        // assings neighbours for each node\n        for (let [index, node] of map.entries()) {\n          let newNeighbours = [];\n          let isRightAvailable = node.xPosition + 1 < mapWidth;\n          let isLeftAvailable = node.xPosition - 1 >= 0;\n          let isBelowAvailable = node.yPosition + 1 < mapHeight;\n          let isAboveAvailable = node.yPosition - 1 >= 0;\n          // diagonal neighbours\n          // let diagonalDistace = 1.414; // approximation of sqrt of 2\n          // if (isRightAvailable && isBelowAvailable) {\n          //   let southEastNeighbour = map[index + 1 + mapWidth] // index + 1 + mapWidth reaches the SE neighbour on the grid \n          //   newNeighbours.push({ node: southEastNeighbour, relativeDistance: diagonalDistace }); \n          // }\n          // if (isRightAvailable && isAboveAvailable) {\n          //   let northEastNeighbour = map[index + 1 - mapWidth]; // index + 1 - mapWidth reaches the NE neighbour on the grid\n          //   newNeighbours.push({ node: northEastNeighbour, relativeDistance: diagonalDistace }); \n          // }\n          // if (isLeftAvailable && isBelowAvailable) {\n          //   let southWestNeighbour = map[index - 1 + mapWidth]; // index - 1 + mapWidth reaches the SW neighbour on the grid\n          //   newNeighbours.push({ node: southWestNeighbour, relativeDistance: diagonalDistace }); \n          // }\n          // if (isLeftAvailable && isAboveAvailable) {\n          //   let northWestNeighbour = map[index - 1 - mapWidth] // index - 1 - mapWidth reaches the NW neighbour on the grid\n          //   newNeighbours.push({ node: northWestNeighbour, relativeDistance: diagonalDistace });\n          // }\n          // normal neighbours\n          let normalDistance = 1;\n          if (isRightAvailable) {\n            let rightNeighbour = map[index + 1]; // index + 1 reaches the neighbour to the right on the grid\n            newNeighbours.push({\n              node: rightNeighbour,\n              relativeDistance: normalDistance\n            });\n          }\n          if (isLeftAvailable) {\n            let leftNeighbour = map[index - 1]; // index - 1 reaches the neighbour to the left on the grid\n            newNeighbours.push({\n              node: leftNeighbour,\n              relativeDistance: normalDistance\n            });\n          }\n          if (isBelowAvailable) {\n            let belowNeighbour = map[index + mapWidth]; // index + mapWidth reaches the neighbour below on the grid\n            newNeighbours.push({\n              node: belowNeighbour,\n              relativeDistance: normalDistance\n            });\n          }\n          if (isAboveAvailable) {\n            let aboveNeighbour = map[index - mapWidth]; // index - mapWidth reaches the neighbour above on the grid\n            newNeighbours.push({\n              node: aboveNeighbour,\n              relativeDistance: normalDistance\n            });\n          }\n          node.neighbours = newNeighbours;\n        }\n        return map;\n      };\n      this.generateRow = (width, yCoord) => {\n        let row = [];\n        for (let xCoord = 0; xCoord < width; xCoord++) {\n          let newNode = {\n            weight: 1,\n            parent: undefined,\n            pathDistance: Infinity,\n            heuristicDistance: Infinity,\n            isVisited: false,\n            isBlocked: false,\n            xPosition: xCoord,\n            yPosition: yCoord,\n            isProspected: false\n          };\n          row.push(newNode);\n        }\n        return row;\n      };\n    }\n  }\n  _class = NodeMapService;\n  _class.ɵfac = function NodeMapService_Factory(t) {\n    return new (t || _class)();\n  };\n  _class.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n    token: _class,\n    factory: _class.ɵfac,\n    providedIn: 'root'\n  });\n  return NodeMapService;\n})();","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}