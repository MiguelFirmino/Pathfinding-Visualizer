{"ast":null,"code":"var _class;\nimport * as i0 from \"@angular/core\";\nexport class AStarService {\n  constructor() {\n    this.heuristicWeight = 1;\n    this.iterationCount = 0;\n    this.doIteration = () => {\n      let [index, closestNode] = this.getClosestNode();\n      this.currentNode = closestNode;\n      // algorithm is done when it reaches ending node\n      if (!this.checkIfDone().isDone) {\n        this.visitNode(closestNode);\n        this.unvisitedNodes.splice(index, 1);\n      }\n      this.iterationCount += 1;\n      return closestNode;\n    };\n    this.setAlgorithmValues = (start, end) => {\n      this.startingNode = start;\n      this.startingNode.pathDistance = 0;\n      this.endingNode = end;\n      this.unvisitedNodes = [this.startingNode];\n      this.iterationCount = 0;\n    };\n    // get node of least distance\n    this.getClosestNode = () => {\n      let closestNode = this.unvisitedNodes[0];\n      let closestNodeIndex = undefined;\n      for (let [index, node] of this.unvisitedNodes.entries()) {\n        if (node.heuristicDistance < closestNode.heuristicDistance) {\n          closestNode = node;\n          closestNodeIndex = index;\n        }\n      }\n      return [closestNodeIndex, closestNode];\n    };\n    this.getUnvisitedNeighbours = node => {\n      let nodeNeighbours = node.neighbours;\n      return [...nodeNeighbours.filter(neighbour => !neighbour.node.isBlocked && !neighbour.node.isVisited)];\n    };\n    // add all adjacent nodes that haven't been visited to unvisitedNodes list\n    // assign adjacent nodes distances and set current node to visited \n    this.visitNode = nodeToVisit => {\n      let unvisitedNeighbours = this.getUnvisitedNeighbours(nodeToVisit);\n      let heuristicDistance = Math.abs(nodeToVisit.xPosition - this.endingNode.xPosition) + Math.abs(nodeToVisit.yPosition - this.endingNode.yPosition);\n      for (let {\n        node: neighbour,\n        relativeDistance\n      } of unvisitedNeighbours) {\n        let potentialDistance = nodeToVisit.pathDistance + relativeDistance;\n        // solve this shitty ass heuristic function\n        if (neighbour.pathDistance > potentialDistance) {\n          neighbour.pathDistance = potentialDistance;\n          neighbour.heuristicDistance = potentialDistance + heuristicDistance * this.heuristicWeight;\n          neighbour.parent = nodeToVisit;\n          if (!this.unvisitedNodes.includes(neighbour)) {\n            this.unvisitedNodes.push(neighbour);\n            neighbour.isProspected = true;\n          }\n        }\n      }\n      if (nodeToVisit !== this.startingNode) {\n        nodeToVisit.isVisited = true;\n      }\n    };\n    this.checkIfDone = () => {\n      if (this.currentNode === this.endingNode) {\n        return {\n          isDone: true,\n          reason: 'reached end'\n        };\n      } else if (this.unvisitedNodes.length == 0) {\n        return {\n          isDone: true,\n          reason: 'no solution'\n        };\n      } else {\n        return {\n          isDone: false\n        };\n      }\n    };\n    // get list of nodes whose parents trace to selected node\n    this.tracePath = nodeToTrace => {\n      let pathNodes = [nodeToTrace];\n      while (nodeToTrace.parent) {\n        nodeToTrace = nodeToTrace.parent;\n        pathNodes.push(nodeToTrace);\n      }\n      return pathNodes;\n    };\n  }\n}\n_class = AStarService;\n_class.ɵfac = function AStarService_Factory(t) {\n  return new (t || _class)();\n};\n_class.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n  token: _class,\n  factory: _class.ɵfac,\n  providedIn: 'root'\n});","map":{"version":3,"names":["AStarService","constructor","heuristicWeight","iterationCount","doIteration","index","closestNode","getClosestNode","currentNode","checkIfDone","isDone","visitNode","unvisitedNodes","splice","setAlgorithmValues","start","end","startingNode","pathDistance","endingNode","closestNodeIndex","undefined","node","entries","heuristicDistance","getUnvisitedNeighbours","nodeNeighbours","neighbours","filter","neighbour","isBlocked","isVisited","nodeToVisit","unvisitedNeighbours","Math","abs","xPosition","yPosition","relativeDistance","potentialDistance","parent","includes","push","isProspected","reason","length","tracePath","nodeToTrace","pathNodes","factory","ɵfac","providedIn"],"sources":["C:\\Users\\Miguel\\Desktop\\algorithm-visualizer\\src\\app\\node-map\\services\\algorithms\\a-star.service.ts"],"sourcesContent":["import { Injectable } from '@angular/core';\nimport { Node } from 'src/app/node/node';\n\n@Injectable({\n  providedIn: 'root'\n})\nexport class AStarService {\n\n  constructor() { }\n\n  startingNode: Node;\n  endingNode: Node;\n  unvisitedNodes: Node[];\n  currentNode: Node;\n  heuristicWeight: number = 1;\n  iterationCount: number = 0;\n\n  doIteration = (): undefined | Node => {\n    let [index, closestNode] = this.getClosestNode();\n    this.currentNode = closestNode;\n\n    // algorithm is done when it reaches ending node\n    if (!this.checkIfDone().isDone) {\n      this.visitNode(closestNode);\n      this.unvisitedNodes.splice(index, 1);\n    } \n\n    this.iterationCount += 1;\n    return closestNode;\n  }\n\n  setAlgorithmValues = (start: Node, end: Node) => {\n    this.startingNode = start;\n    this.startingNode.pathDistance = 0;\n    this.endingNode = end;\n    this.unvisitedNodes = [this.startingNode];\n    this.iterationCount = 0;\n  }\n\n  // get node of least distance\n  getClosestNode = () => {\n    let closestNode = this.unvisitedNodes[0];\n    let closestNodeIndex = undefined;\n\n    for (let [index, node] of this.unvisitedNodes.entries()) {\n      if (node.heuristicDistance < closestNode.heuristicDistance) {\n          closestNode = node;\n          closestNodeIndex = index;\n      }\n    }\n\n    return [closestNodeIndex, closestNode];\n  }\n\n  getUnvisitedNeighbours = (node: Node) => {\n    let nodeNeighbours = node.neighbours\n\n    return [...nodeNeighbours.filter((neighbour) => !neighbour.node.isBlocked && !neighbour.node.isVisited)];\n  }\n\n  // add all adjacent nodes that haven't been visited to unvisitedNodes list\n  // assign adjacent nodes distances and set current node to visited \n  visitNode = (nodeToVisit: Node) => {\n    let unvisitedNeighbours = this.getUnvisitedNeighbours(nodeToVisit);\n\n    let heuristicDistance = Math.abs(nodeToVisit.xPosition - this.endingNode.xPosition)\n       + Math.abs(nodeToVisit.yPosition - this.endingNode.yPosition);\n    for (let { node: neighbour, relativeDistance } of unvisitedNeighbours) {\n      let potentialDistance = nodeToVisit.pathDistance + relativeDistance;\n      // solve this shitty ass heuristic function\n      \n\n      if (neighbour.pathDistance > potentialDistance) {\n        neighbour.pathDistance = potentialDistance;\n        neighbour.heuristicDistance = potentialDistance + (heuristicDistance * this.heuristicWeight);\n        neighbour.parent = nodeToVisit;\n\n        if (!this.unvisitedNodes.includes(neighbour)) {\n          this.unvisitedNodes.push(neighbour);\n          neighbour.isProspected = true;\n        }\n      }\n    }\n\n    if (nodeToVisit !== this.startingNode) {\n      nodeToVisit.isVisited = true;\n    }\n  }\n\n  checkIfDone = (): { isDone: boolean, reason?: string } => {\n    if (this.currentNode === this.endingNode) {\n      return { isDone: true, reason: 'reached end' };\n    } else if (this.unvisitedNodes.length == 0) {\n      return { isDone: true, reason: 'no solution' };\n    } else {\n      return { isDone: false };\n    }\n  }\n\n  // get list of nodes whose parents trace to selected node\n  tracePath = (nodeToTrace: Node) => {\n    let pathNodes = [nodeToTrace];\n\n    while (nodeToTrace.parent) {\n      nodeToTrace = nodeToTrace.parent;\n      pathNodes.push(nodeToTrace);\n    }\n\n    return pathNodes;\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}