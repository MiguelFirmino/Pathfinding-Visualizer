{"ast":null,"code":"var _class;\nimport * as i0 from \"@angular/core\";\nexport class NodeMapService {\n  constructor() {\n    this.generateMap = (mapWidth, mapHeight) => {\n      let map = [];\n      // generate nodes\n      for (let i = 0; i < mapHeight; i++) {\n        map.push(...this.generateRow(mapWidth, i));\n      }\n      // assings neighbours for each node IMPLEMENT DISTANCE IF NEEDED\n      for (let [index, node] of map.entries()) {\n        let newNeighbours = [];\n        let isRightAvailable = node.xPosition + 1 < mapWidth;\n        let isLeftAvailable = node.xPosition - 1 >= 0;\n        let isBelowAvailable = node.yPosition + 1 < mapHeight;\n        let isAboveAvailable = node.yPosition - 1 >= 0;\n        // diagonal neighbours\n        let diagonalDistace = 1.414; // approximation of sqrt of 2\n        if (isRightAvailable && isBelowAvailable) {\n          let southEastNeighbour = map[index + 1 + mapWidth]; // index + 1 + mapWidth reaches the SE neighbour on the grid \n          newNeighbours.push({\n            node: southEastNeighbour,\n            relativeDistance: diagonalDistace\n          });\n        }\n        if (isRightAvailable && isAboveAvailable) {\n          let northEastNeighbour = map[index + 1 - mapWidth]; // index + 1 - mapWidth reaches the NE neighbour on the grid\n          newNeighbours.push({\n            node: northEastNeighbour,\n            relativeDistance: diagonalDistace\n          });\n        }\n        if (isLeftAvailable && isBelowAvailable) {\n          let southWestNeighbour = map[index - 1 + mapWidth]; // index - 1 + mapWidth reaches the SW neighbour on the grid\n          newNeighbours.push({\n            node: southWestNeighbour,\n            relativeDistance: diagonalDistace\n          });\n        }\n        if (isLeftAvailable && isAboveAvailable) {\n          let northWestNeighbour = map[index - 1 - mapWidth]; // index - 1 - mapWidth reaches the NW neighbour on the grid\n          newNeighbours.push({\n            node: northWestNeighbour,\n            relativeDistance: diagonalDistace\n          });\n        }\n        // normal neighbours\n        let normalDistance = 1;\n        if (isRightAvailable) {\n          let rightNeighbour = map[index + 1]; // index + 1 reaches the neighbour to the right on the grid\n          newNeighbours.push({\n            node: rightNeighbour,\n            relativeDistance: normalDistance\n          });\n        }\n        if (isLeftAvailable) {\n          let leftNeighbour = map[index - 1]; // index - 1 reaches the neighbour to the left on the grid\n          newNeighbours.push({\n            node: leftNeighbour,\n            relativeDistance: normalDistance\n          });\n        }\n        if (isBelowAvailable) {\n          let belowNeighbour = map[index + mapWidth]; // index + mapWidth reaches the neighbour below on the grid\n          newNeighbours.push({\n            node: belowNeighbour,\n            relativeDistance: normalDistance\n          });\n        }\n        if (isAboveAvailable) {\n          let aboveNeighbour = map[index - mapWidth]; // index - mapWidth reaches the neighbour above on the grid\n          newNeighbours.push({\n            node: aboveNeighbour,\n            relativeDistance: normalDistance\n          });\n        }\n        node.neighbours = newNeighbours;\n      }\n      return map;\n    };\n    this.generateRow = (width, yCoord) => {\n      let row = [];\n      for (let xCoord = 0; xCoord < width; xCoord++) {\n        let newNode = {\n          weight: 1,\n          parent: undefined,\n          pathDistance: Infinity,\n          heuristicDistance: Infinity,\n          isVisited: false,\n          isBlocked: false,\n          xPosition: xCoord,\n          yPosition: yCoord,\n          isProspected: false\n        };\n        row.push(newNode);\n      }\n      return row;\n    };\n  }\n}\n_class = NodeMapService;\n_class.ɵfac = function NodeMapService_Factory(t) {\n  return new (t || _class)();\n};\n_class.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n  token: _class,\n  factory: _class.ɵfac,\n  providedIn: 'root'\n});","map":{"version":3,"names":["NodeMapService","constructor","generateMap","mapWidth","mapHeight","map","i","push","generateRow","index","node","entries","newNeighbours","isRightAvailable","xPosition","isLeftAvailable","isBelowAvailable","yPosition","isAboveAvailable","diagonalDistace","southEastNeighbour","relativeDistance","northEastNeighbour","southWestNeighbour","northWestNeighbour","normalDistance","rightNeighbour","leftNeighbour","belowNeighbour","aboveNeighbour","neighbours","width","yCoord","row","xCoord","newNode","weight","parent","undefined","pathDistance","Infinity","heuristicDistance","isVisited","isBlocked","isProspected","factory","ɵfac","providedIn"],"sources":["C:\\Users\\Miguel\\Desktop\\algorithm-visualizer\\src\\app\\node-map\\services\\node-map.service.ts"],"sourcesContent":["import { Injectable } from '@angular/core';\r\nimport { Node } from '../../node/node';\r\n\r\n@Injectable({\r\n  providedIn: 'root'\r\n})\r\nexport class NodeMapService {\r\n  generateMap = (mapWidth: number, mapHeight: number) => {\r\n    let map: Node[] = [];\r\n\r\n    // generate nodes\r\n    for (let i = 0; i < mapHeight; i++) {\r\n      map.push(...this.generateRow(mapWidth, i));\r\n    } \r\n\r\n    // assings neighbours for each node IMPLEMENT DISTANCE IF NEEDED\r\n    for (let [index, node] of map.entries()) {\r\n      let newNeighbours = [];\r\n\r\n      let isRightAvailable: boolean = node.xPosition + 1 < mapWidth;\r\n      let isLeftAvailable: boolean = node.xPosition - 1 >= 0;\r\n      let isBelowAvailable: boolean = node.yPosition + 1 < mapHeight;\r\n      let isAboveAvailable: boolean = node.yPosition - 1 >= 0;\r\n\r\n      // diagonal neighbours\r\n      let diagonalDistace = 1.414; // approximation of sqrt of 2\r\n      if (isRightAvailable && isBelowAvailable) {\r\n        let southEastNeighbour = map[index + 1 + mapWidth] // index + 1 + mapWidth reaches the SE neighbour on the grid \r\n        newNeighbours.push({ node: southEastNeighbour, relativeDistance: diagonalDistace }); \r\n      }\r\n      if (isRightAvailable && isAboveAvailable) {\r\n        let northEastNeighbour = map[index + 1 - mapWidth]; // index + 1 - mapWidth reaches the NE neighbour on the grid\r\n        newNeighbours.push({ node: northEastNeighbour, relativeDistance: diagonalDistace }); \r\n      }\r\n      if (isLeftAvailable && isBelowAvailable) {\r\n        let southWestNeighbour = map[index - 1 + mapWidth]; // index - 1 + mapWidth reaches the SW neighbour on the grid\r\n        newNeighbours.push({ node: southWestNeighbour, relativeDistance: diagonalDistace }); \r\n      }\r\n      if (isLeftAvailable && isAboveAvailable) {\r\n        let northWestNeighbour = map[index - 1 - mapWidth] // index - 1 - mapWidth reaches the NW neighbour on the grid\r\n        newNeighbours.push({ node: northWestNeighbour, relativeDistance: diagonalDistace });\r\n      }\r\n\r\n      // normal neighbours\r\n      let normalDistance = 1;\r\n      if (isRightAvailable) {\r\n        let rightNeighbour = map[index + 1]; // index + 1 reaches the neighbour to the right on the grid\r\n        newNeighbours.push({ node: rightNeighbour, relativeDistance: normalDistance }); \r\n      }\r\n      if (isLeftAvailable) {\r\n        let leftNeighbour = map[index - 1]; // index - 1 reaches the neighbour to the left on the grid\r\n        newNeighbours.push({ node: leftNeighbour, relativeDistance: normalDistance }); \r\n      }\r\n      if (isBelowAvailable) {\r\n        let belowNeighbour = map[index + mapWidth]; // index + mapWidth reaches the neighbour below on the grid\r\n        newNeighbours.push({ node: belowNeighbour, relativeDistance: normalDistance }); \r\n      }\r\n      if (isAboveAvailable) {\r\n        let aboveNeighbour = map[index - mapWidth]; // index - mapWidth reaches the neighbour above on the grid\r\n        newNeighbours.push({ node: aboveNeighbour, relativeDistance: normalDistance }); \r\n      }\r\n\r\n      node.neighbours = newNeighbours;\r\n    }\r\n\r\n    return map;\r\n  }\r\n\r\n  generateRow = (width: number, yCoord: number): Node[] => {\r\n    let row: Node[] = [];\r\n\r\n    for (let xCoord = 0; xCoord < width; xCoord++) {\r\n      let newNode: Node = {\r\n        weight: 1,\r\n        parent: undefined,\r\n        pathDistance: Infinity,\r\n        heuristicDistance: Infinity,\r\n        isVisited: false,\r\n        isBlocked: false,\r\n        xPosition: xCoord,\r\n        yPosition: yCoord,\r\n        isProspected: false\r\n      }\r\n\r\n      row.push(newNode);\r\n    }\r\n\r\n    return row;\r\n  }\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}