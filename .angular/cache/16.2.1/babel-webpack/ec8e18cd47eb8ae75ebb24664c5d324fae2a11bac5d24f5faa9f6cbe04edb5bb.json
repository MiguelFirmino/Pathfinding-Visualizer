{"ast":null,"code":"import * as i0 from \"@angular/core\";\nimport * as i1 from \"./services/node-map.service\";\nimport * as i2 from \"./services/algorithms/dijkstra.service\";\nimport * as i3 from \"./services/algorithms/a-star.service\";\nimport * as i4 from \"./services/algorithms/depth-first-search.service\";\nimport * as i5 from \"@angular/common\";\nimport * as i6 from \"../node/node.component\";\nconst _c0 = function (a1, a2, a3, a4, a5, a6) {\n  return {\n    \"node\": true,\n    \"blocked\": a1,\n    \"path-node\": a2,\n    \"prospected\": a3,\n    \"visited\": a4,\n    \"start-node\": a5,\n    \"end-node\": a6\n  };\n};\nfunction NodeMapComponent_app_node_4_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r3 = i0.ɵɵgetCurrentView();\n    i0.ɵɵelementStart(0, \"app-node\", 2);\n    i0.ɵɵlistener(\"nodeClickEvent\", function NodeMapComponent_app_node_4_Template_app_node_nodeClickEvent_0_listener($event) {\n      i0.ɵɵrestoreView(_r3);\n      const ctx_r2 = i0.ɵɵnextContext();\n      return i0.ɵɵresetView(ctx_r2.receiveClickedNode($event));\n    })(\"nodeMoveEvent\", function NodeMapComponent_app_node_4_Template_app_node_nodeMoveEvent_0_listener($event) {\n      i0.ɵɵrestoreView(_r3);\n      const ctx_r4 = i0.ɵɵnextContext();\n      return i0.ɵɵresetView(ctx_r4.receiveMovedNode($event));\n    });\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const node_r1 = ctx.$implicit;\n    const ctx_r0 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"node\", node_r1)(\"ngClass\", i0.ɵɵpureFunction6(2, _c0, node_r1.isBlocked, ctx_r0.nodePath.includes(node_r1), node_r1.isProspected, node_r1.isVisited, node_r1 == ctx_r0.startingNode, node_r1 == ctx_r0.endingNode));\n  }\n}\nconst _c1 = function (a1) {\n  return {\n    \"node-map\": true,\n    \"disabled-animations\": a1\n  };\n};\nexport let NodeMapComponent = /*#__PURE__*/(() => {\n  var _class;\n  class NodeMapComponent {\n    onKeyDown() {\n      this.doCompleteCycle();\n    }\n    constructor(nodeMapService, dijkstraService, aStartService, depthFirstSearchService) {\n      this.nodeMapService = nodeMapService;\n      this.dijkstraService = dijkstraService;\n      this.aStartService = aStartService;\n      this.depthFirstSearchService = depthFirstSearchService;\n      this.message = '';\n      this.clearMap = () => {\n        for (let node of this.nodeMap) {\n          node.parent = undefined;\n          node.pathDistance = Infinity;\n          node.heuristicDistance = Infinity;\n          node.isVisited = false;\n          node.isProspected = false;\n        }\n        clearInterval(this.pathAnimationInterval);\n        this.nodePath = [];\n        this.stopAlgorithm();\n      };\n      this.receiveClickedNode = node => {\n        // console.log(\n        //   `Node at x: ${node.xPosition}, y: ${node.yPosition} has been clicked`\n        // );\n        console.log(this.nodeMap.indexOf(node));\n        // set node function depending on what kind of node was clicked\n        if (node === this.startingNode) {\n          this.nodeFunction = this.setStartingNode;\n        } else if (node === this.endingNode) {\n          this.nodeFunction = this.setEndingNode;\n        } else if (!node.isBlocked) {\n          this.blockNode(node);\n          this.nodeFunction = this.blockNode;\n        } else {\n          this.unblockNode(node);\n          this.nodeFunction = this.unblockNode;\n        }\n      };\n      this.receiveMovedNode = node => {\n        // do function that was previously defined on mousedown\n        this.nodeFunction(node);\n      };\n      this.blockNode = node => {\n        if (node !== this.startingNode && node !== this.endingNode && (!node.isVisited && !node.isProspected || !this.isAlgorithmOperating)) {\n          console.log(`Node at ${node.xPosition}, ${node.yPosition} is now %cblocked`, 'color: yellow');\n          node.isBlocked = true;\n        } else {\n          console.log(`%cUnable to block node at ${node.xPosition}, ${node.yPosition}`, 'color: red');\n          return;\n        }\n        this.autoComplete();\n      };\n      this.unblockNode = node => {\n        if (node.isBlocked) {\n          console.log(`Node at ${node.xPosition}, ${node.yPosition} is now %cunblocked`, 'color: lightgreen');\n          node.isBlocked = false;\n        }\n        this.autoComplete();\n      };\n      this.setStartingNode = node => {\n        if (!node.isBlocked && node != this.endingNode && !this.isAlgorithmOperating) {\n          console.log(`Node at ${node.xPosition}, ${node.yPosition} is now %cstarting Node`, 'color: lightblue');\n          this.startingNode = node;\n        } else {\n          console.log(`%cUnable to set node at ${node.xPosition}, ${node.yPosition} as starting node`, 'color: red');\n          return;\n        }\n        this.autoComplete();\n      };\n      this.setEndingNode = node => {\n        if (!node.isBlocked && node != this.startingNode && !this.isAlgorithmOperating) {\n          console.log(`Node at ${node.xPosition}, ${node.yPosition} is %cnow ending Node`, 'color: lightgreen');\n          this.endingNode = node;\n        } else {\n          console.log(`%cUnable to set node at ${node.xPosition}, ${node.yPosition} as ending node`, 'color: red');\n          return;\n        }\n        this.autoComplete();\n      };\n      this.startAlgorithm = () => {\n        this.isAnimated = true;\n        this.clearMap();\n        this.algorithmService.setAlgorithmValues(this.startingNode, this.endingNode);\n        this.resumeAlgorithm();\n      };\n      this.stopAlgorithm = () => {\n        clearInterval(this.algorithmInterval);\n        this.isAlgorithmOperating = false;\n      };\n      this.resumeAlgorithm = () => {\n        this.algorithmInterval = setInterval(() => {\n          this.doAlgorithmIteration();\n        }, this.algorithmDelay);\n        this.isAlgorithmOperating = true;\n      };\n      this.doAlgorithmIteration = () => {\n        this.algorithmService.doIteration();\n        // trace path to node being visited\n        let currentNode = this.algorithmService.currentNode;\n        // this.nodePath = this.algorithmService.tracePath(currentNode);\n        let {\n          isDone,\n          reason\n        } = this.algorithmService.checkIfDone();\n        if (isDone == true) {\n          this.stopAlgorithm();\n          if (reason == 'reached end') {\n            // this.message = `Reached End Node after ${this.aStarService.iterationCount} steps`;\n            console.log(`Reached End Node after ${this.algorithmService.iterationCount} steps`);\n            let path = this.algorithmService.tracePath(currentNode);\n            this.animatePath(path);\n          } else {\n            // this.message = `No solution available after ${this.aStarService.iterationCount} steps`;\n            console.log(`No solution available after ${this.algorithmService.iterationCount} steps`);\n            this.nodePath = [];\n          }\n        }\n      };\n      this.changeAlgorithmDelay = newDelay => {\n        this.algorithmDelay = newDelay;\n        if (this.isAlgorithmOperating) {\n          this.stopAlgorithm();\n          this.resumeAlgorithm();\n        }\n      };\n      this.changeAlgorithmService = newAlgorithm => {\n        console.log(`(from node-map) %cchanged algorithm to ${newAlgorithm}`, 'color: lightgreen');\n        switch (newAlgorithm) {\n          case 'dijkstra':\n            this.algorithmService = this.dijkstraService;\n            break;\n          case 'a-star':\n            this.algorithmService = this.aStartService;\n            break;\n          case 'depth-first-search':\n            this.algorithmService = this.depthFirstSearchService;\n            break;\n        }\n        this.autoComplete();\n      };\n      this.toggleInstantVisualization = () => {\n        this.isInstaOn = !this.isInstaOn;\n        this.autoComplete();\n      };\n      this.autoComplete = () => {\n        if (this.isInstaOn) {\n          this.doCompleteCycle();\n        }\n      };\n      // MAKE THIS MORE READABLE\n      this.doCompleteCycle = () => {\n        // disable animations to prevent information cluster\n        this.isAnimated = false;\n        clearInterval(this.pathAnimationInterval);\n        this.clearMap();\n        this.algorithmService.setAlgorithmValues(this.startingNode, this.endingNode);\n        this.algorithmService.doCompleteCycle();\n        if (this.algorithmService.checkIfDone().reason != 'no solution') {\n          let path = this.algorithmService.tracePath(this.algorithmService.currentNode);\n          // this.animatePath(path);\n          this.nodePath = path;\n        }\n      };\n      this.animatePath = path => {\n        let animationDelay = 2000 / path.length ** 2;\n        // from start to finish\n        this.pathAnimationInterval = setInterval(() => {\n          if (path.length > 0) {\n            this.nodePath.push(path.pop());\n          } else {\n            clearInterval(this.pathAnimationInterval);\n          }\n        }, animationDelay);\n        // from finish to start\n        // this.pathAnimationInterval = setInterval(() => {\n        //   if (path.length > 0) {\n        //     this.nodePath.push(path.pop())\n        //   } else {\n        //     clearInterval(this.pathAnimationInterval);\n        //   }\n        // }, 20);\n        // random selection\n        // this.pathAnimationInterval = setInterval(() => {\n        //   if (path.length > 0) {\n        //     let randomIndex = Math.floor(Math.random()*path.length);\n        //     this.nodePath.push(path[randomIndex]);\n        //     path.splice(randomIndex, 1);\n        //   } else {\n        //     clearInterval(this.pathAnimationInterval);\n        //   }\n        // }, 20);\n      };\n    }\n    // default parameters\n    ngOnInit() {\n      this.algorithmDelay = 50; // 50\n      this.mapWidth = 60; // 60\n      this.mapHeight = 30; // 30\n      this.nodeMap = this.nodeMapService.generateMap(this.mapWidth, this.mapHeight);\n      this.startingNode = this.nodeMap[30]; // 854\n      this.endingNode = this.nodeMap[60]; // 885\n      this.nodePath = [];\n      this.isAlgorithmOperating = false;\n      this.algorithmDelay = 50; // 50\n      this.algorithmService = this.dijkstraService;\n      this.isAnimated = true; // true\n    }\n  }\n  _class = NodeMapComponent;\n  _class.ɵfac = function NodeMapComponent_Factory(t) {\n    return new (t || _class)(i0.ɵɵdirectiveInject(i1.NodeMapService), i0.ɵɵdirectiveInject(i2.DijkstraService), i0.ɵɵdirectiveInject(i3.AStarService), i0.ɵɵdirectiveInject(i4.DepthFirstSearchService));\n  };\n  _class.ɵcmp = /*@__PURE__*/i0.ɵɵdefineComponent({\n    type: _class,\n    selectors: [[\"app-node-map\"]],\n    hostBindings: function NodeMapComponent_HostBindings(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵlistener(\"keydown.Space\", function NodeMapComponent_keydown_Space_HostBindingHandler() {\n          return ctx.onKeyDown();\n        }, false, i0.ɵɵresolveDocument);\n      }\n    },\n    decls: 5,\n    vars: 9,\n    consts: [[3, \"ngClass\"], [3, \"node\", \"ngClass\", \"nodeClickEvent\", \"nodeMoveEvent\", 4, \"ngFor\", \"ngForOf\"], [3, \"node\", \"ngClass\", \"nodeClickEvent\", \"nodeMoveEvent\"]],\n    template: function NodeMapComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵelement(0, \"hr\");\n        i0.ɵɵelementStart(1, \"h3\");\n        i0.ɵɵtext(2);\n        i0.ɵɵelementEnd();\n        i0.ɵɵelementStart(3, \"div\", 0);\n        i0.ɵɵtemplate(4, NodeMapComponent_app_node_4_Template, 1, 9, \"app-node\", 1);\n        i0.ɵɵelementEnd();\n      }\n      if (rf & 2) {\n        i0.ɵɵadvance(2);\n        i0.ɵɵtextInterpolate1(\" \", ctx.message, \"\");\n        i0.ɵɵadvance(1);\n        i0.ɵɵstyleProp(\"--map-width\", ctx.mapWidth)(\"--map-height\", ctx.mapHeight);\n        i0.ɵɵproperty(\"ngClass\", i0.ɵɵpureFunction1(7, _c1, !ctx.isAnimated));\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngForOf\", ctx.nodeMap);\n      }\n    },\n    dependencies: [i5.NgClass, i5.NgForOf, i6.NodeComponent],\n    styles: [\".disabled-animations[_ngcontent-%COMP%]   .node[_ngcontent-%COMP%]{animation:none!important}.disabled-animations[_ngcontent-%COMP%]   .node[_ngcontent-%COMP%]:hover{transition:none!important;transform:none!important}.node-map[_ngcontent-%COMP%]{box-sizing:content-box;border-width:1px 0 0 1px;border-style:solid;border-color:#000;margin:0 auto;position:relative;display:flex;flex-wrap:wrap;--parent-width: calc(1.12vw * var(--map-width));--parent-height: calc(1.12vw * var(--map-height));width:var(--parent-width);height:var(--parent-height)}.node-map[_ngcontent-%COMP%]   .node[_ngcontent-%COMP%]{background-color:var(--blank-node-bg);border-width:0 1px 1px 0;border-style:solid;border-color:#000;-webkit-user-select:none;user-select:none;text-align:center;width:calc(var(--parent-width) / var(--map-width));height:calc(var(--parent-height) / var(--map-height));transition:transform .15s ease-in-out}@keyframes _ngcontent-%COMP%_nodeAnim{0%{transform:scale(1.2) rotate(-8deg)}to{transform:scale(1) rotate(0)}}.node-map[_ngcontent-%COMP%]   .node[_ngcontent-%COMP%]:hover{cursor:pointer;transform:scale(1.2)}.node-map[_ngcontent-%COMP%]   .prospected[_ngcontent-%COMP%]{background-color:var(--prospected-node-bg)}.node-map[_ngcontent-%COMP%]   .visited[_ngcontent-%COMP%]{background-color:var(--visited-node-bg);animation:_ngcontent-%COMP%_visitedAnim .25s}@keyframes _ngcontent-%COMP%_visitedAnim{0%{transform:scale(1.2)}to{transform:scale(1)}}.node-map[_ngcontent-%COMP%]   .path-node[_ngcontent-%COMP%]{background-color:var(--path-node-bg);animation:_ngcontent-%COMP%_pathNodeAnim .3s}@keyframes _ngcontent-%COMP%_pathNodeAnim{0%{transform:scale(.8)}30%{transform:scale(1.2)}to{transform:scale(1)}}.node-map[_ngcontent-%COMP%]   .blocked[_ngcontent-%COMP%]{background-color:var(--blocked-node-bg);animation:_ngcontent-%COMP%_blockAnim .2s ease-out!important}@keyframes _ngcontent-%COMP%_blockAnim{0%{background-color:initial;transform:scale(1.3) rotate(8deg)}50%{background-color:var(--blocked-node-bg)}to{transform:scale(1) rotate(0)}}.node-map[_ngcontent-%COMP%]   .start-node[_ngcontent-%COMP%]{background-color:var(--start-node-bg);animation:_ngcontent-%COMP%_startNodeAnim .15s}@keyframes _ngcontent-%COMP%_startNodeAnim{0%{transform:scale(.7)}to{transform:scale(1)}}.node-map[_ngcontent-%COMP%]   .end-node[_ngcontent-%COMP%]{background-color:var(--end-node-bg);animation:_ngcontent-%COMP%_endNodeAnim .15s ease-out}@keyframes _ngcontent-%COMP%_endNodeAnim{0%{transform:scale(.7)}to{transform:scale(1)}}\"]\n  });\n  return NodeMapComponent;\n})();","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}