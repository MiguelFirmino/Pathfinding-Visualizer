{"ast":null,"code":"var _class;\nimport { Pathfinder } from './pathfinder';\nimport * as i0 from \"@angular/core\";\nexport class DijkstraService extends Pathfinder {\n  constructor() {\n    super(...arguments);\n    this.doIteration = () => {\n      console.log(super.setAlgorithmValues);\n      let [index, closestNode] = this.getClosestNodeFromList(this.unvisitedNodes);\n      this.currentNode = closestNode;\n      // algorithm will do iteration regardless of if it's done or not\n      this.visitNode(closestNode);\n      this.unvisitedNodes.splice(index, 1);\n      this.iterationCount += 1;\n    };\n    // get node of least distance\n    this.getClosestNodeFromList = nodeList => {\n      let closestNode = nodeList[0];\n      let closestNodeIndex = undefined;\n      for (let [index, node] of nodeList.entries()) {\n        if (node.pathDistance < closestNode.pathDistance) {\n          closestNode = node;\n          closestNodeIndex = index;\n        }\n      }\n      return [closestNodeIndex, closestNode];\n    };\n    // add all adjacent nodes that haven't been visited to unvisitedNodes list\n    // assign adjacent nodes distances and set current node to visited \n    this.visitNode = nodeToVisit => {\n      let unvisitedNeighbours = this.getUnvisitedNeighbours(nodeToVisit);\n      for (let {\n        node: neighbour,\n        relativeDistance\n      } of unvisitedNeighbours) {\n        let potentialDistance = nodeToVisit.pathDistance + relativeDistance;\n        if (neighbour.pathDistance > potentialDistance) {\n          neighbour.pathDistance = potentialDistance;\n          neighbour.parent = nodeToVisit;\n          // if (!this.unvisitedNodes.includes(neighbour)) {\n          //   this.unvisitedNodes.push(neighbour);\n          //   neighbour.isProspected = true;\n          // }\n          this.unvisitedNodes.push(neighbour);\n          neighbour.isProspected = true;\n        }\n      }\n      nodeToVisit.isVisited = true;\n    };\n  }\n}\n_class = DijkstraService;\n_class.ɵfac = /*@__PURE__*/function () {\n  let ɵDijkstraService_BaseFactory;\n  return function DijkstraService_Factory(t) {\n    return (ɵDijkstraService_BaseFactory || (ɵDijkstraService_BaseFactory = i0.ɵɵgetInheritedFactory(_class)))(t || _class);\n  };\n}();\n_class.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n  token: _class,\n  factory: _class.ɵfac,\n  providedIn: 'root'\n});","map":{"version":3,"names":["Pathfinder","DijkstraService","constructor","doIteration","console","log","setAlgorithmValues","index","closestNode","getClosestNodeFromList","unvisitedNodes","currentNode","visitNode","splice","iterationCount","nodeList","closestNodeIndex","undefined","node","entries","pathDistance","nodeToVisit","unvisitedNeighbours","getUnvisitedNeighbours","neighbour","relativeDistance","potentialDistance","parent","push","isProspected","isVisited","t","factory","ɵfac","providedIn"],"sources":["C:\\Users\\Miguel\\Desktop\\algorithm-visualizer\\src\\app\\node-map\\services\\algorithms\\dijkstra.service.ts"],"sourcesContent":["import { Injectable } from '@angular/core';\nimport { Pathfinder } from './pathfinder';\nimport { Node } from 'src/app/node/node';\n\n@Injectable({\n  providedIn: 'root'\n})\nexport class DijkstraService extends Pathfinder {\n\n  override doIteration = (): void => {\n    console.log(super.setAlgorithmValues);\n    let [index, closestNode] = this.getClosestNodeFromList(this.unvisitedNodes);\n    this.currentNode = closestNode;\n\n    // algorithm will do iteration regardless of if it's done or not\n    this.visitNode(closestNode);\n    this.unvisitedNodes.splice(index, 1);\n\n    this.iterationCount += 1;\n  }\n\n  // get node of least distance\n  getClosestNodeFromList = (nodeList : Node[]) => {\n    let closestNode = nodeList[0];\n    let closestNodeIndex = undefined;\n\n    for (let [index, node] of nodeList.entries()) {\n      if (node.pathDistance < closestNode.pathDistance) {\n          closestNode = node;\n          closestNodeIndex = index;\n      }\n    }\n\n    return [closestNodeIndex, closestNode];\n  }\n\n  // add all adjacent nodes that haven't been visited to unvisitedNodes list\n  // assign adjacent nodes distances and set current node to visited \n  visitNode = (nodeToVisit: Node) => {\n    let unvisitedNeighbours = this.getUnvisitedNeighbours(nodeToVisit);\n\n    for (let { node: neighbour, relativeDistance } of unvisitedNeighbours) {\n      let potentialDistance = nodeToVisit.pathDistance + relativeDistance;\n\n      if (neighbour.pathDistance > potentialDistance) {\n        neighbour.pathDistance = potentialDistance;\n        neighbour.parent = nodeToVisit;\n\n        // if (!this.unvisitedNodes.includes(neighbour)) {\n        //   this.unvisitedNodes.push(neighbour);\n        //   neighbour.isProspected = true;\n        // }\n        this.unvisitedNodes.push(neighbour);\n        neighbour.isProspected = true;\n      }\n    }\n\n    nodeToVisit.isVisited = true;\n  }\n}\n"],"mappings":";AACA,SAASA,UAAU,QAAQ,cAAc;;AAMzC,OAAM,MAAOC,eAAgB,SAAQD,UAAU;EAH/CE,YAAA;;IAKW,KAAAC,WAAW,GAAG,MAAW;MAChCC,OAAO,CAACC,GAAG,CAAC,KAAK,CAACC,kBAAkB,CAAC;MACrC,IAAI,CAACC,KAAK,EAAEC,WAAW,CAAC,GAAG,IAAI,CAACC,sBAAsB,CAAC,IAAI,CAACC,cAAc,CAAC;MAC3E,IAAI,CAACC,WAAW,GAAGH,WAAW;MAE9B;MACA,IAAI,CAACI,SAAS,CAACJ,WAAW,CAAC;MAC3B,IAAI,CAACE,cAAc,CAACG,MAAM,CAACN,KAAK,EAAE,CAAC,CAAC;MAEpC,IAAI,CAACO,cAAc,IAAI,CAAC;IAC1B,CAAC;IAED;IACA,KAAAL,sBAAsB,GAAIM,QAAiB,IAAI;MAC7C,IAAIP,WAAW,GAAGO,QAAQ,CAAC,CAAC,CAAC;MAC7B,IAAIC,gBAAgB,GAAGC,SAAS;MAEhC,KAAK,IAAI,CAACV,KAAK,EAAEW,IAAI,CAAC,IAAIH,QAAQ,CAACI,OAAO,EAAE,EAAE;QAC5C,IAAID,IAAI,CAACE,YAAY,GAAGZ,WAAW,CAACY,YAAY,EAAE;UAC9CZ,WAAW,GAAGU,IAAI;UAClBF,gBAAgB,GAAGT,KAAK;;;MAI9B,OAAO,CAACS,gBAAgB,EAAER,WAAW,CAAC;IACxC,CAAC;IAED;IACA;IACA,KAAAI,SAAS,GAAIS,WAAiB,IAAI;MAChC,IAAIC,mBAAmB,GAAG,IAAI,CAACC,sBAAsB,CAACF,WAAW,CAAC;MAElE,KAAK,IAAI;QAAEH,IAAI,EAAEM,SAAS;QAAEC;MAAgB,CAAE,IAAIH,mBAAmB,EAAE;QACrE,IAAII,iBAAiB,GAAGL,WAAW,CAACD,YAAY,GAAGK,gBAAgB;QAEnE,IAAID,SAAS,CAACJ,YAAY,GAAGM,iBAAiB,EAAE;UAC9CF,SAAS,CAACJ,YAAY,GAAGM,iBAAiB;UAC1CF,SAAS,CAACG,MAAM,GAAGN,WAAW;UAE9B;UACA;UACA;UACA;UACA,IAAI,CAACX,cAAc,CAACkB,IAAI,CAACJ,SAAS,CAAC;UACnCA,SAAS,CAACK,YAAY,GAAG,IAAI;;;MAIjCR,WAAW,CAACS,SAAS,GAAG,IAAI;IAC9B,CAAC;;;SAnDU7B,eAAgB;;;;qGAAhBA,MAAe,IAAA8B,CAAA,IAAf9B,MAAe;EAAA;AAAA;;SAAfA,MAAe;EAAA+B,OAAA,EAAf/B,MAAe,CAAAgC,IAAA;EAAAC,UAAA,EAFd;AAAM"},"metadata":{},"sourceType":"module","externalDependencies":[]}