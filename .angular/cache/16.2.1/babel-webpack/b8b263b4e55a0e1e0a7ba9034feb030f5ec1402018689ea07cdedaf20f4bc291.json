{"ast":null,"code":"// base class for all pathfinding algorithms\nexport class Pathfinder {\n  constructor() {\n    this.iterationCount = 0;\n    this.getUnvisitedNeighbours = node => {\n      let nodeNeighbours = node.neighbours;\n      return [...nodeNeighbours.filter(neighbour => !neighbour.node.isBlocked && !neighbour.node.isVisited)];\n    };\n    this.checkIfDone = () => {\n      if (this.currentNode === this.endingNode) {\n        return {\n          isDone: true,\n          reason: 'reached end'\n        };\n      } else if (this.unvisitedNodes.length == 0) {\n        return {\n          isDone: true,\n          reason: 'no solution'\n        };\n      } else {\n        return {\n          isDone: false\n        };\n      }\n    };\n    this.doCompleteCycle = callback => {\n      while (!this.checkIfDone().isDone) {\n        this.doIteration();\n      }\n      if (typeof callback == \"function\") {\n        callback();\n      }\n      return this.currentNode;\n    };\n    this.tracePath = nodeToTrace => {\n      let pathNodes = [];\n      while (nodeToTrace.parent) {\n        pathNodes.push(nodeToTrace);\n        nodeToTrace = nodeToTrace.parent;\n      }\n      return pathNodes;\n    };\n  }\n  setAlgorithmValues(start, end) {\n    this.startingNode = start;\n    this.startingNode.pathDistance = 0;\n    this.endingNode = end;\n    this.unvisitedNodes = [start];\n    this.currentNode = start;\n    this.iterationCount = 0;\n  }\n}","map":{"version":3,"names":["Pathfinder","constructor","iterationCount","getUnvisitedNeighbours","node","nodeNeighbours","neighbours","filter","neighbour","isBlocked","isVisited","checkIfDone","currentNode","endingNode","isDone","reason","unvisitedNodes","length","doCompleteCycle","callback","doIteration","tracePath","nodeToTrace","pathNodes","parent","push","setAlgorithmValues","start","end","startingNode","pathDistance"],"sources":["C:\\Users\\Miguel\\Desktop\\algorithm-visualizer\\src\\app\\node-map\\services\\algorithms\\pathfinder.ts"],"sourcesContent":["import { Node } from 'src/app/node/node';\r\n\r\n// base class for all pathfinding algorithms\r\nexport class Pathfinder {\r\n  startingNode: Node;\r\n  endingNode: Node;\r\n  unvisitedNodes: Node[];\r\n  currentNode: Node;\r\n  iterationCount: number = 0;\r\n  doIteration: any;\r\n\r\n  setAlgorithmValues(start: Node, end: Node) {\r\n    this.startingNode = start;\r\n    this.startingNode.pathDistance = 0;\r\n    this.endingNode = end;\r\n    this.unvisitedNodes = [start];\r\n    this.currentNode = start;\r\n    this.iterationCount = 0;\r\n  };\r\n\r\n  getUnvisitedNeighbours = (node: Node) => {\r\n    let nodeNeighbours = node.neighbours\r\n\r\n    return [...nodeNeighbours.filter((neighbour) => !neighbour.node.isBlocked && !neighbour.node.isVisited)];\r\n  };\r\n\r\n  checkIfDone = (): { isDone: boolean, reason?: string } => {\r\n    if (this.currentNode === this.endingNode) {\r\n      return { isDone: true, reason: 'reached end' };\r\n    } else if (this.unvisitedNodes.length == 0) {\r\n      return { isDone: true, reason: 'no solution' };\r\n    } else {\r\n      return { isDone: false };\r\n    }\r\n  };\r\n\r\n  doCompleteCycle = (callback?) => {\r\n    while (!this.checkIfDone().isDone) {\r\n      this.doIteration();\r\n    }\r\n\r\n    if (typeof callback == \"function\") {\r\n      callback();\r\n    }\r\n\r\n    return this.currentNode;\r\n  }\r\n\r\n  tracePath = (nodeToTrace: Node) => {\r\n    let pathNodes = [];\r\n\r\n    while (nodeToTrace.parent) {\r\n      pathNodes.push(nodeToTrace);\r\n      nodeToTrace = nodeToTrace.parent;\r\n    }\r\n\r\n    return pathNodes;\r\n  }\r\n}\r\n"],"mappings":"AAEA;AACA,OAAM,MAAOA,UAAU;EAAvBC,YAAA;IAKE,KAAAC,cAAc,GAAW,CAAC;IAY1B,KAAAC,sBAAsB,GAAIC,IAAU,IAAI;MACtC,IAAIC,cAAc,GAAGD,IAAI,CAACE,UAAU;MAEpC,OAAO,CAAC,GAAGD,cAAc,CAACE,MAAM,CAAEC,SAAS,IAAK,CAACA,SAAS,CAACJ,IAAI,CAACK,SAAS,IAAI,CAACD,SAAS,CAACJ,IAAI,CAACM,SAAS,CAAC,CAAC;IAC1G,CAAC;IAED,KAAAC,WAAW,GAAG,MAA2C;MACvD,IAAI,IAAI,CAACC,WAAW,KAAK,IAAI,CAACC,UAAU,EAAE;QACxC,OAAO;UAAEC,MAAM,EAAE,IAAI;UAAEC,MAAM,EAAE;QAAa,CAAE;OAC/C,MAAM,IAAI,IAAI,CAACC,cAAc,CAACC,MAAM,IAAI,CAAC,EAAE;QAC1C,OAAO;UAAEH,MAAM,EAAE,IAAI;UAAEC,MAAM,EAAE;QAAa,CAAE;OAC/C,MAAM;QACL,OAAO;UAAED,MAAM,EAAE;QAAK,CAAE;;IAE5B,CAAC;IAED,KAAAI,eAAe,GAAIC,QAAS,IAAI;MAC9B,OAAO,CAAC,IAAI,CAACR,WAAW,EAAE,CAACG,MAAM,EAAE;QACjC,IAAI,CAACM,WAAW,EAAE;;MAGpB,IAAI,OAAOD,QAAQ,IAAI,UAAU,EAAE;QACjCA,QAAQ,EAAE;;MAGZ,OAAO,IAAI,CAACP,WAAW;IACzB,CAAC;IAED,KAAAS,SAAS,GAAIC,WAAiB,IAAI;MAChC,IAAIC,SAAS,GAAG,EAAE;MAElB,OAAOD,WAAW,CAACE,MAAM,EAAE;QACzBD,SAAS,CAACE,IAAI,CAACH,WAAW,CAAC;QAC3BA,WAAW,GAAGA,WAAW,CAACE,MAAM;;MAGlC,OAAOD,SAAS;IAClB,CAAC;EACH;EA/CEG,kBAAkBA,CAACC,KAAW,EAAEC,GAAS;IACvC,IAAI,CAACC,YAAY,GAAGF,KAAK;IACzB,IAAI,CAACE,YAAY,CAACC,YAAY,GAAG,CAAC;IAClC,IAAI,CAACjB,UAAU,GAAGe,GAAG;IACrB,IAAI,CAACZ,cAAc,GAAG,CAACW,KAAK,CAAC;IAC7B,IAAI,CAACf,WAAW,GAAGe,KAAK;IACxB,IAAI,CAACzB,cAAc,GAAG,CAAC;EACzB"},"metadata":{},"sourceType":"module","externalDependencies":[]}