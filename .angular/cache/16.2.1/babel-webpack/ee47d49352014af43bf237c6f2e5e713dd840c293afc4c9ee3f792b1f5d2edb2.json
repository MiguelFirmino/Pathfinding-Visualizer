{"ast":null,"code":"// base class for all pathfinding algorithms\nexport class Pathfinder {\n  constructor() {\n    this.iterationCount = 0;\n    this.getUnvisitedNeighbours = node => {\n      let nodeNeighbours = node.neighbours;\n      return [...nodeNeighbours.filter(neighbour => !neighbour.node.isBlocked && !neighbour.node.isVisited)];\n    };\n    this.checkIfDone = () => {\n      if (this.currentNode === this.endingNode) {\n        return {\n          isDone: true,\n          reason: 'reached end'\n        };\n      } else if (this.unvisitedNodes.length == 0) {\n        return {\n          isDone: true,\n          reason: 'no solution'\n        };\n      } else {\n        return {\n          isDone: false\n        };\n      }\n    };\n    this.doCompleteCycle = () => {\n      while (!this.checkIfDone().isDone) {\n        this.doIteration();\n      }\n    };\n    this.tracePath = nodeToTrace => {\n      let pathNodes = [];\n      while (nodeToTrace.parent) {\n        pathNodes.push(nodeToTrace);\n        nodeToTrace = nodeToTrace.parent;\n      }\n      return pathNodes;\n    };\n  }\n  setAlgorithmValues(start, end) {\n    this.startingNode = start;\n    this.startingNode.pathDistance = 0;\n    this.endingNode = end;\n    this.unvisitedNodes = [start];\n    this.currentNode = start;\n    this.iterationCount = 0;\n  }\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}