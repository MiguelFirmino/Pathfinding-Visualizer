{"ast":null,"code":"var _class;\nimport { DijkstraService } from './dijkstra.service';\nimport * as i0 from \"@angular/core\";\n// bidirectional swarm works the same way as dijkstra\nexport class BidirectionalService extends DijkstraService {\n  constructor() {\n    super(...arguments);\n    this.setAlgorithmValues = (start, end) => {\n      // set everything the same way as other algorithms\n      console.log(super.checkIfDone);\n      this.currentNodeFromEnd = end;\n      this.unvisitedNodesFromEnd = [];\n    };\n    this.doIteration = () => {\n      // this block ensures that the algorithm goes back and forth \n      // from searching from the start to end\n      let currentList;\n      if (this.iterationCount % 2 == 0) {\n        currentList = this.unvisitedNodes;\n        var [index, closestNode] = this.getClosestNodeFromList(currentList);\n        this.currentNode = closestNode;\n      } else {\n        currentList = this.unvisitedNodesFromEnd;\n        var [index, closestNode] = this.getClosestNodeFromList(currentList);\n        this.currentNodeFromEnd = closestNode;\n      }\n      // algorithm will do iteration regardless of if it's done or not\n      this.visitNode(closestNode);\n      currentList.splice(index, 1);\n      this.iterationCount += 1;\n    };\n    this.checkIfDone = () => {\n      if (this.currentNode === this.currentNodeFromEnd) {\n        return {\n          isDone: true,\n          reason: 'reached end'\n        };\n      } else if (this.unvisitedNodes.length == 0) {\n        return {\n          isDone: true,\n          reason: 'no solution'\n        };\n      } else {\n        return {\n          isDone: false\n        };\n      }\n    };\n    this.tracePath = nodeToTrace => {\n      let pathNodes = [];\n      nodeToTrace = this.startingNode;\n      while (nodeToTrace.parent) {\n        pathNodes.push(nodeToTrace);\n        nodeToTrace = nodeToTrace.parent;\n      }\n      nodeToTrace = this.endingNode;\n      while (nodeToTrace.parent) {\n        pathNodes.push(nodeToTrace);\n        nodeToTrace = nodeToTrace.parent;\n      }\n      return pathNodes;\n    };\n  }\n}\n_class = BidirectionalService;\n_class.ɵfac = /*@__PURE__*/function () {\n  let ɵBidirectionalService_BaseFactory;\n  return function BidirectionalService_Factory(t) {\n    return (ɵBidirectionalService_BaseFactory || (ɵBidirectionalService_BaseFactory = i0.ɵɵgetInheritedFactory(_class)))(t || _class);\n  };\n}();\n_class.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n  token: _class,\n  factory: _class.ɵfac,\n  providedIn: 'root'\n});","map":{"version":3,"names":["DijkstraService","BidirectionalService","constructor","setAlgorithmValues","start","end","console","log","checkIfDone","currentNodeFromEnd","unvisitedNodesFromEnd","doIteration","currentList","iterationCount","unvisitedNodes","index","closestNode","getClosestNodeFromList","currentNode","visitNode","splice","isDone","reason","length","tracePath","nodeToTrace","pathNodes","startingNode","parent","push","endingNode","t","factory","ɵfac","providedIn"],"sources":["C:\\Users\\Miguel\\Desktop\\algorithm-visualizer\\src\\app\\node-map\\services\\algorithms\\bidirectional.service.ts"],"sourcesContent":["import { Injectable } from '@angular/core';\nimport { Node } from 'src/app/node/node';\nimport { DijkstraService } from './dijkstra.service';\n\n@Injectable({\n  providedIn: 'root'\n})\n// bidirectional swarm works the same way as dijkstra\nexport class BidirectionalService extends DijkstraService {\n\n  currentNodeFromEnd: Node;\n  unvisitedNodesFromEnd: Node[];\n\n  override setAlgorithmValues = (start: Node, end: Node) => {\n    // set everything the same way as other algorithms\n    console.log(super.checkIfDone);\n    this.currentNodeFromEnd = end;\n    this.unvisitedNodesFromEnd = [];\n  };\n\n  override doIteration = (): void => {\n    // this block ensures that the algorithm goes back and forth \n    // from searching from the start to end\n    let currentList: Node[];\n    if (this.iterationCount % 2 == 0) {\n      currentList = this.unvisitedNodes;\n      var [index, closestNode] = this.getClosestNodeFromList(currentList);\n      this.currentNode = closestNode;\n  \n    } else {\n      currentList = this.unvisitedNodesFromEnd;\n      var [index, closestNode] = this.getClosestNodeFromList(currentList);\n      this.currentNodeFromEnd = closestNode;\n    }\n\n    // algorithm will do iteration regardless of if it's done or not\n    this.visitNode(closestNode);\n    currentList.splice(index, 1);\n\n    this.iterationCount += 1;\n  }\n\n  override checkIfDone = (): { isDone: boolean, reason?: string } => { \n    if (this.currentNode === this.currentNodeFromEnd) {\n      return { isDone: true, reason: 'reached end' };\n    } else if (this.unvisitedNodes.length == 0) {\n      return { isDone: true, reason: 'no solution' };\n    } else {\n      return { isDone: false };\n    }\n  }\n\n  override tracePath = (nodeToTrace?: Node): Node[] => {\n    let pathNodes = [];\n\n    nodeToTrace = this.startingNode;\n    while (nodeToTrace.parent) {\n      pathNodes.push(nodeToTrace);\n      nodeToTrace = nodeToTrace.parent;\n    }\n\n    nodeToTrace = this.endingNode;\n    while (nodeToTrace.parent) {\n      pathNodes.push(nodeToTrace);\n      nodeToTrace = nodeToTrace.parent;\n    }\n\n    return pathNodes;\n  };\n}\n"],"mappings":";AAEA,SAASA,eAAe,QAAQ,oBAAoB;;AAKpD;AACA,OAAM,MAAOC,oBAAqB,SAAQD,eAAe;EAJzDE,YAAA;;IASW,KAAAC,kBAAkB,GAAG,CAACC,KAAW,EAAEC,GAAS,KAAI;MACvD;MACAC,OAAO,CAACC,GAAG,CAAC,KAAK,CAACC,WAAW,CAAC;MAC9B,IAAI,CAACC,kBAAkB,GAAGJ,GAAG;MAC7B,IAAI,CAACK,qBAAqB,GAAG,EAAE;IACjC,CAAC;IAEQ,KAAAC,WAAW,GAAG,MAAW;MAChC;MACA;MACA,IAAIC,WAAmB;MACvB,IAAI,IAAI,CAACC,cAAc,GAAG,CAAC,IAAI,CAAC,EAAE;QAChCD,WAAW,GAAG,IAAI,CAACE,cAAc;QACjC,IAAI,CAACC,KAAK,EAAEC,WAAW,CAAC,GAAG,IAAI,CAACC,sBAAsB,CAACL,WAAW,CAAC;QACnE,IAAI,CAACM,WAAW,GAAGF,WAAW;OAE/B,MAAM;QACLJ,WAAW,GAAG,IAAI,CAACF,qBAAqB;QACxC,IAAI,CAACK,KAAK,EAAEC,WAAW,CAAC,GAAG,IAAI,CAACC,sBAAsB,CAACL,WAAW,CAAC;QACnE,IAAI,CAACH,kBAAkB,GAAGO,WAAW;;MAGvC;MACA,IAAI,CAACG,SAAS,CAACH,WAAW,CAAC;MAC3BJ,WAAW,CAACQ,MAAM,CAACL,KAAK,EAAE,CAAC,CAAC;MAE5B,IAAI,CAACF,cAAc,IAAI,CAAC;IAC1B,CAAC;IAEQ,KAAAL,WAAW,GAAG,MAA2C;MAChE,IAAI,IAAI,CAACU,WAAW,KAAK,IAAI,CAACT,kBAAkB,EAAE;QAChD,OAAO;UAAEY,MAAM,EAAE,IAAI;UAAEC,MAAM,EAAE;QAAa,CAAE;OAC/C,MAAM,IAAI,IAAI,CAACR,cAAc,CAACS,MAAM,IAAI,CAAC,EAAE;QAC1C,OAAO;UAAEF,MAAM,EAAE,IAAI;UAAEC,MAAM,EAAE;QAAa,CAAE;OAC/C,MAAM;QACL,OAAO;UAAED,MAAM,EAAE;QAAK,CAAE;;IAE5B,CAAC;IAEQ,KAAAG,SAAS,GAAIC,WAAkB,IAAY;MAClD,IAAIC,SAAS,GAAG,EAAE;MAElBD,WAAW,GAAG,IAAI,CAACE,YAAY;MAC/B,OAAOF,WAAW,CAACG,MAAM,EAAE;QACzBF,SAAS,CAACG,IAAI,CAACJ,WAAW,CAAC;QAC3BA,WAAW,GAAGA,WAAW,CAACG,MAAM;;MAGlCH,WAAW,GAAG,IAAI,CAACK,UAAU;MAC7B,OAAOL,WAAW,CAACG,MAAM,EAAE;QACzBF,SAAS,CAACG,IAAI,CAACJ,WAAW,CAAC;QAC3BA,WAAW,GAAGA,WAAW,CAACG,MAAM;;MAGlC,OAAOF,SAAS;IAClB,CAAC;;;SA5DUzB,oBAAqB;;;;+GAArBA,MAAoB,IAAA8B,CAAA,IAApB9B,MAAoB;EAAA;AAAA;;SAApBA,MAAoB;EAAA+B,OAAA,EAApB/B,MAAoB,CAAAgC,IAAA;EAAAC,UAAA,EAHnB;AAAM"},"metadata":{},"sourceType":"module","externalDependencies":[]}