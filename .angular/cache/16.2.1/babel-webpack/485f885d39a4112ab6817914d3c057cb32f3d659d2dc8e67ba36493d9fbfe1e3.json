{"ast":null,"code":"var _class;\nimport { Pathfinder } from './pathfinder';\nimport * as i0 from \"@angular/core\";\nexport class DepthFirstSearchService extends Pathfinder {\n  constructor() {\n    super(...arguments);\n    this.doIteration = () => {\n      let mostRecentNode = this.unvisitedNodes.pop();\n      this.currentNode = mostRecentNode;\n      // algorithm will do iteration regardless of if it's done or not\n      this.visitNode(mostRecentNode);\n      this.iterationCount += 1;\n    };\n    // add all adjacent nodes that haven't been visited to unvisitedNodes list\n    this.visitNode = nodeToVisit => {\n      let unvisitedNeighbours = this.getUnvisitedNeighbours(nodeToVisit);\n      for (let {\n        node: neighbour\n      } of unvisitedNeighbours) {\n        neighbour.parent = nodeToVisit;\n        if (!this.unvisitedNodes.includes(neighbour)) {\n          this.unvisitedNodes.push(neighbour);\n          neighbour.isProspected = true;\n        }\n      }\n      nodeToVisit.isVisited = true;\n    };\n  }\n}\n_class = DepthFirstSearchService;\n_class.ɵfac = /*@__PURE__*/function () {\n  let ɵDepthFirstSearchService_BaseFactory;\n  return function DepthFirstSearchService_Factory(t) {\n    return (ɵDepthFirstSearchService_BaseFactory || (ɵDepthFirstSearchService_BaseFactory = i0.ɵɵgetInheritedFactory(_class)))(t || _class);\n  };\n}();\n_class.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n  token: _class,\n  factory: _class.ɵfac,\n  providedIn: 'root'\n});","map":{"version":3,"names":["Pathfinder","DepthFirstSearchService","constructor","doIteration","mostRecentNode","unvisitedNodes","pop","currentNode","visitNode","iterationCount","nodeToVisit","unvisitedNeighbours","getUnvisitedNeighbours","node","neighbour","parent","includes","push","isProspected","isVisited","t","factory","ɵfac","providedIn"],"sources":["C:\\Users\\Miguel\\Desktop\\algorithm-visualizer\\src\\app\\node-map\\services\\algorithms\\depth-first-search.service.ts"],"sourcesContent":["import { Injectable } from '@angular/core';\nimport { Node } from 'src/app/node/node';\nimport { Pathfinder } from './pathfinder';\n\n@Injectable({\n  providedIn: 'root'\n})\nexport class DepthFirstSearchService extends Pathfinder {\n\n  override doIteration = (): void => {\n    let mostRecentNode = this.unvisitedNodes.pop();\n    this.currentNode = mostRecentNode;\n\n    // algorithm will do iteration regardless of if it's done or not\n    this.visitNode(mostRecentNode);\n\n    this.iterationCount += 1;\n  }\n\n  // add all adjacent nodes that haven't been visited to unvisitedNodes list\n  visitNode = (nodeToVisit: Node) => {\n    let unvisitedNeighbours = this.getUnvisitedNeighbours(nodeToVisit);\n\n    for (let { node: neighbour } of unvisitedNeighbours) {\n      neighbour.parent = nodeToVisit;\n\n      if (!this.unvisitedNodes.includes(neighbour)) {\n        this.unvisitedNodes.push(neighbour);\n        neighbour.isProspected = true;\n      }\n    }\n\n    nodeToVisit.isVisited = true;\n  }\n}"],"mappings":";AAEA,SAASA,UAAU,QAAQ,cAAc;;AAKzC,OAAM,MAAOC,uBAAwB,SAAQD,UAAU;EAHvDE,YAAA;;IAKW,KAAAC,WAAW,GAAG,MAAW;MAChC,IAAIC,cAAc,GAAG,IAAI,CAACC,cAAc,CAACC,GAAG,EAAE;MAC9C,IAAI,CAACC,WAAW,GAAGH,cAAc;MAEjC;MACA,IAAI,CAACI,SAAS,CAACJ,cAAc,CAAC;MAE9B,IAAI,CAACK,cAAc,IAAI,CAAC;IAC1B,CAAC;IAED;IACA,KAAAD,SAAS,GAAIE,WAAiB,IAAI;MAChC,IAAIC,mBAAmB,GAAG,IAAI,CAACC,sBAAsB,CAACF,WAAW,CAAC;MAElE,KAAK,IAAI;QAAEG,IAAI,EAAEC;MAAS,CAAE,IAAIH,mBAAmB,EAAE;QACnDG,SAAS,CAACC,MAAM,GAAGL,WAAW;QAE9B,IAAI,CAAC,IAAI,CAACL,cAAc,CAACW,QAAQ,CAACF,SAAS,CAAC,EAAE;UAC5C,IAAI,CAACT,cAAc,CAACY,IAAI,CAACH,SAAS,CAAC;UACnCA,SAAS,CAACI,YAAY,GAAG,IAAI;;;MAIjCR,WAAW,CAACS,SAAS,GAAG,IAAI;IAC9B,CAAC;;;SA1BUlB,uBAAwB;;;;qHAAxBA,MAAuB,IAAAmB,CAAA,IAAvBnB,MAAuB;EAAA;AAAA;;SAAvBA,MAAuB;EAAAoB,OAAA,EAAvBpB,MAAuB,CAAAqB,IAAA;EAAAC,UAAA,EAFtB;AAAM"},"metadata":{},"sourceType":"module","externalDependencies":[]}