{"ast":null,"code":"import { Pathfinder } from './pathfinder';\nimport * as i0 from \"@angular/core\";\nexport let AStarService = /*#__PURE__*/(() => {\n  var _class;\n  class AStarService extends Pathfinder {\n    constructor() {\n      super(...arguments);\n      this.heuristicWeight = 0.8;\n      this.doIteration = () => {\n        let [index, closestNode] = this.getClosestNode();\n        this.currentNode = closestNode;\n        // algorithm will do iteration regardless of if it's done or not\n        this.visitNode(closestNode);\n        this.unvisitedNodes.splice(index, 1);\n        this.iterationCount += 1;\n      };\n      // get node of least heuristic distance\n      this.getClosestNode = () => {\n        let closestNode = this.unvisitedNodes[0];\n        let closestNodeIndex = undefined;\n        for (let [index, node] of this.unvisitedNodes.entries()) {\n          if (node.heuristicDistance < closestNode.heuristicDistance) {\n            closestNode = node;\n            closestNodeIndex = index;\n          }\n        }\n        return [closestNodeIndex, closestNode];\n      };\n      // add all adjacent nodes that haven't been visited to unvisitedNodes list\n      // assign adjacent nodes distances and set current node to visited \n      this.visitNode = nodeToVisit => {\n        let unvisitedNeighbours = this.getUnvisitedNeighbours(nodeToVisit);\n        for (let {\n          node: neighbour,\n          relativeDistance\n        } of unvisitedNeighbours) {\n          let potentialDistance = nodeToVisit.pathDistance + relativeDistance;\n          let heuristicDistance = Math.abs(neighbour.xPosition - this.endingNode.xPosition) + Math.abs(neighbour.yPosition - this.endingNode.yPosition);\n          if (neighbour.pathDistance > potentialDistance) {\n            neighbour.pathDistance = potentialDistance;\n            neighbour.heuristicDistance = potentialDistance + heuristicDistance * this.heuristicWeight;\n            neighbour.parent = nodeToVisit;\n            if (!this.unvisitedNodes.includes(neighbour)) {\n              this.unvisitedNodes.push(neighbour);\n              neighbour.isProspected = true;\n            }\n          }\n        }\n        nodeToVisit.isVisited = true;\n      };\n    }\n  }\n  _class = AStarService;\n  _class.ɵfac = /*@__PURE__*/function () {\n    let ɵAStarService_BaseFactory;\n    return function AStarService_Factory(t) {\n      return (ɵAStarService_BaseFactory || (ɵAStarService_BaseFactory = i0.ɵɵgetInheritedFactory(_class)))(t || _class);\n    };\n  }();\n  _class.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n    token: _class,\n    factory: _class.ɵfac,\n    providedIn: 'root'\n  });\n  return AStarService;\n})();","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}