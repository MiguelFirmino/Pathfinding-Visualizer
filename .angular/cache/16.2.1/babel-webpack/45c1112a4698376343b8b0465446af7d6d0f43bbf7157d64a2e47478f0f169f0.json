{"ast":null,"code":"var _class;\nimport { Pathfinder } from './pathfinder';\nimport * as i0 from \"@angular/core\";\n// bidirectional swarm works the same way as dijkstra\nexport class BidirectionalService extends Pathfinder {\n  constructor() {\n    super(...arguments);\n    this.setAlgorithmValues = (start, end) => {\n      // set everything the same way as other algorithms\n      super.setAlgorithmValues(start, end);\n      this.endingNode.pathDistance = 0;\n      this.currentNodeFromEnd = end;\n      this.unvisitedNodesFromEnd = [end];\n    };\n    this.doIteration = () => {\n      // this block ensures that the algorithm goes back and forth \n      // from searching from the start to end\n      let currentList;\n      if (this.iterationCount % 2 == 0) {\n        currentList = this.unvisitedNodes;\n        var [index, closestNode] = this.getClosestNodeFromList(currentList);\n        this.currentNode = closestNode;\n      } else {\n        currentList = this.unvisitedNodesFromEnd;\n        var [index, closestNode] = this.getClosestNodeFromList(currentList);\n        this.currentNodeFromEnd = closestNode;\n      }\n      // algorithm will do iteration regardless of if it's done or not\n      this.visitNode(closestNode);\n      currentList.splice(index, 1);\n      this.iterationCount += 1;\n    };\n    this.getClosestNodeFromList = nodeList => {\n      let closestNode = nodeList[0];\n      let closestNodeIndex = undefined;\n      for (let [index, node] of nodeList.entries()) {\n        if (node.pathDistance < closestNode.pathDistance) {\n          closestNode = node;\n          closestNodeIndex = index;\n        }\n      }\n      return [closestNodeIndex, closestNode];\n    };\n    this.checkIfDone = () => {\n      if (this.currentNode === this.currentNodeFromEnd) {\n        return {\n          isDone: true,\n          reason: 'reached end'\n        };\n      } else if (this.unvisitedNodes.length == 0 && this.unvisitedNodesFromEnd.length == 0) {\n        return {\n          isDone: true,\n          reason: 'no solution'\n        };\n      } else {\n        return {\n          isDone: false\n        };\n      }\n    };\n    this.tracePath = nodeToTrace => {\n      let pathNodes = [];\n      nodeToTrace = this.startingNode;\n      while (nodeToTrace.parent) {\n        pathNodes.push(nodeToTrace);\n        nodeToTrace = nodeToTrace.parent;\n      }\n      nodeToTrace = this.endingNode;\n      while (nodeToTrace.parent) {\n        pathNodes.push(nodeToTrace);\n        nodeToTrace = nodeToTrace.parent;\n      }\n      return pathNodes;\n    };\n  }\n}\n_class = BidirectionalService;\n_class.ɵfac = /*@__PURE__*/function () {\n  let ɵBidirectionalService_BaseFactory;\n  return function BidirectionalService_Factory(t) {\n    return (ɵBidirectionalService_BaseFactory || (ɵBidirectionalService_BaseFactory = i0.ɵɵgetInheritedFactory(_class)))(t || _class);\n  };\n}();\n_class.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n  token: _class,\n  factory: _class.ɵfac,\n  providedIn: 'root'\n});","map":{"version":3,"names":["Pathfinder","BidirectionalService","constructor","setAlgorithmValues","start","end","endingNode","pathDistance","currentNodeFromEnd","unvisitedNodesFromEnd","doIteration","currentList","iterationCount","unvisitedNodes","index","closestNode","getClosestNodeFromList","currentNode","visitNode","splice","nodeList","closestNodeIndex","undefined","node","entries","checkIfDone","isDone","reason","length","tracePath","nodeToTrace","pathNodes","startingNode","parent","push","t","factory","ɵfac","providedIn"],"sources":["C:\\Users\\Miguel\\Desktop\\algorithm-visualizer\\src\\app\\node-map\\services\\algorithms\\bidirectional.service.ts"],"sourcesContent":["import { Injectable } from '@angular/core';\nimport { Node } from 'src/app/node/node';\nimport { Pathfinder } from './pathfinder';\n\n@Injectable({\n  providedIn: 'root'\n})\n// bidirectional swarm works the same way as dijkstra\nexport class BidirectionalService extends Pathfinder {\n\n  currentNodeFromEnd: Node;\n  unvisitedNodesFromEnd: Node[];\n\n  override setAlgorithmValues = (start: Node, end: Node) => {\n    // set everything the same way as other algorithms\n    super.setAlgorithmValues(start, end);\n    this.endingNode.pathDistance = 0;\n    this.currentNodeFromEnd = end;\n    this.unvisitedNodesFromEnd = [end];\n  };\n\n  override doIteration = (): void => {\n    // this block ensures that the algorithm goes back and forth \n    // from searching from the start to end\n    let currentList: Node[];\n    if (this.iterationCount % 2 == 0) {\n      currentList = this.unvisitedNodes;\n      var [index, closestNode] = this.getClosestNodeFromList(currentList);\n      this.currentNode = closestNode;\n  \n    } else {\n      currentList = this.unvisitedNodesFromEnd;\n      var [index, closestNode] = this.getClosestNodeFromList(currentList);\n      this.currentNodeFromEnd = closestNode;\n    }\n\n    // algorithm will do iteration regardless of if it's done or not\n    this.visitNode(closestNode);\n    currentList.splice(index, 1);\n\n    this.iterationCount += 1;\n  }\n\n  getClosestNodeFromList = (nodeList: Node[]) => {\n    let closestNode = nodeList[0];\n    let closestNodeIndex = undefined;\n\n    for (let [index, node] of nodeList.entries()) {\n      if (node.pathDistance < closestNode.pathDistance) {\n          closestNode = node;\n          closestNodeIndex = index;\n      }\n    }\n\n    return [closestNodeIndex, closestNode];\n  }\n\n  override checkIfDone = (): { isDone: boolean, reason?: string } => { \n    if (this.currentNode === this.currentNodeFromEnd) {\n      return { isDone: true, reason: 'reached end' };\n    } else if (this.unvisitedNodes.length == 0 &&\n       this.unvisitedNodesFromEnd.length == 0) {\n      return { isDone: true, reason: 'no solution' };\n    } else {\n      return { isDone: false };\n    }\n  }\n\n  override tracePath = (nodeToTrace?: Node): Node[] => {\n    let pathNodes = [];\n\n    nodeToTrace = this.startingNode;\n    while (nodeToTrace.parent) {\n      pathNodes.push(nodeToTrace);\n      nodeToTrace = nodeToTrace.parent;\n    }\n\n    nodeToTrace = this.endingNode;\n    while (nodeToTrace.parent) {\n      pathNodes.push(nodeToTrace);\n      nodeToTrace = nodeToTrace.parent;\n    }\n\n    return pathNodes;\n  };\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}