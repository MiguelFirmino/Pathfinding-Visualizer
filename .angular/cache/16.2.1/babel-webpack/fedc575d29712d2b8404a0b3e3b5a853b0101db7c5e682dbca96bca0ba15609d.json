{"ast":null,"code":"var _class;\nimport { Pathfinder } from './pathfinder';\nimport * as i0 from \"@angular/core\";\n// bidirectional swarm works the same way as dijkstra\nexport class BidirectionalService extends Pathfinder {\n  constructor() {\n    super(...arguments);\n    this.setAlgorithmValues = (start, end) => {\n      // set everything the same way as other algorithms\n      super.setAlgorithmValues(start, end);\n      this.endingNode.pathDistance = 0;\n      this.currentNodeFromEnd = undefined;\n      this.unvisitedNodesFromEnd = [end];\n    };\n    this.doIteration = () => {\n      // this block ensures that the algorithm goes back and forth \n      // from searching from the start to end\n      let currentList;\n      if (this.iterationCount % 2 == 0) {\n        currentList = this.unvisitedNodes;\n        var [index, closestNode] = this.getClosestNodeFromList(currentList);\n        this.currentNode = closestNode;\n        closestNode.isVisited = true;\n      } else {\n        currentList = this.unvisitedNodesFromEnd;\n        var [index, closestNode] = this.getClosestNodeFromList(currentList);\n        this.currentNodeFromEnd = closestNode;\n        closestNode.isVisitedFromEnd = true;\n      }\n      // algorithm will do iteration regardless of if it's done or not\n      this.visitNodeFromList(closestNode, currentList);\n      currentList.splice(index, 1);\n      this.iterationCount += 1;\n    };\n    this.getClosestNodeFromList = nodeList => {\n      let closestNode = nodeList[0];\n      let closestNodeIndex = undefined;\n      for (let [index, node] of nodeList.entries()) {\n        if (node.pathDistance < closestNode.pathDistance) {\n          closestNode = node;\n          closestNodeIndex = index;\n        }\n      }\n      return [closestNodeIndex, closestNode];\n    };\n    this.visitNodeFromList = (nodeToVisit, unvisitedList) => {\n      let unvisitedNeighbours = this.getUnvisitedNeighbours(nodeToVisit);\n      for (let {\n        node: neighbour,\n        relativeDistance\n      } of unvisitedNeighbours) {\n        let potentialDistance = nodeToVisit.pathDistance + relativeDistance;\n        if (neighbour.pathDistance > potentialDistance) {\n          neighbour.pathDistance = potentialDistance;\n          neighbour.parent = nodeToVisit;\n          // if (!this.unvisitedNodes.includes(neighbour)) {\n          //   this.unvisitedNodes.push(neighbour);\n          //   neighbour.isProspected = true;\n          // }\n          unvisitedList.push(neighbour);\n          neighbour.isProspected = true;\n        }\n      }\n    };\n    this.checkIfDone = () => {\n      if (this.currentNode.isVisited && this.currentNode.isVisitedFromEnd) {\n        return {\n          isDone: true,\n          reason: 'reached end'\n        };\n      } else if (this.unvisitedNodes.length == 0 && this.unvisitedNodesFromEnd.length == 0) {\n        return {\n          isDone: true,\n          reason: 'no solution'\n        };\n      } else {\n        return {\n          isDone: false\n        };\n      }\n    };\n    this.tracePath = nodeToTrace => {\n      let pathNodes = [];\n      nodeToTrace = this.startingNode;\n      while (nodeToTrace.parent) {\n        pathNodes.push(nodeToTrace);\n        nodeToTrace = nodeToTrace.parent;\n      }\n      nodeToTrace = this.endingNode;\n      while (nodeToTrace.parent) {\n        pathNodes.push(nodeToTrace);\n        nodeToTrace = nodeToTrace.parent;\n      }\n      return pathNodes;\n    };\n  }\n}\n_class = BidirectionalService;\n_class.ɵfac = /*@__PURE__*/function () {\n  let ɵBidirectionalService_BaseFactory;\n  return function BidirectionalService_Factory(t) {\n    return (ɵBidirectionalService_BaseFactory || (ɵBidirectionalService_BaseFactory = i0.ɵɵgetInheritedFactory(_class)))(t || _class);\n  };\n}();\n_class.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n  token: _class,\n  factory: _class.ɵfac,\n  providedIn: 'root'\n});","map":{"version":3,"names":["Pathfinder","BidirectionalService","constructor","setAlgorithmValues","start","end","endingNode","pathDistance","currentNodeFromEnd","undefined","unvisitedNodesFromEnd","doIteration","currentList","iterationCount","unvisitedNodes","index","closestNode","getClosestNodeFromList","currentNode","isVisited","isVisitedFromEnd","visitNodeFromList","splice","nodeList","closestNodeIndex","node","entries","nodeToVisit","unvisitedList","unvisitedNeighbours","getUnvisitedNeighbours","neighbour","relativeDistance","potentialDistance","parent","push","isProspected","checkIfDone","isDone","reason","length","tracePath","nodeToTrace","pathNodes","startingNode","t","factory","ɵfac","providedIn"],"sources":["C:\\Users\\Miguel\\Desktop\\algorithm-visualizer\\src\\app\\node-map\\services\\algorithms\\bidirectional.service.ts"],"sourcesContent":["import { Injectable } from '@angular/core';\nimport { Node } from 'src/app/node/node';\nimport { Pathfinder } from './pathfinder';\n\n@Injectable({\n  providedIn: 'root'\n})\n// bidirectional swarm works the same way as dijkstra\nexport class BidirectionalService extends Pathfinder {\n\n  currentNodeFromEnd: Node;\n  unvisitedNodesFromEnd: Node[];\n\n  override setAlgorithmValues = (start: Node, end: Node) => {\n    // set everything the same way as other algorithms\n    super.setAlgorithmValues(start, end);\n    this.endingNode.pathDistance = 0;\n    this.currentNodeFromEnd = undefined;\n    this.unvisitedNodesFromEnd = [end];\n  };\n\n  override doIteration = (): void => {\n    // this block ensures that the algorithm goes back and forth \n    // from searching from the start to end\n    let currentList: Node[];\n    if (this.iterationCount % 2 == 0) {\n      currentList = this.unvisitedNodes;\n      var [index, closestNode] = this.getClosestNodeFromList(currentList);\n      this.currentNode = closestNode;\n      closestNode.isVisited = true;\n    } else {\n      currentList = this.unvisitedNodesFromEnd;\n      var [index, closestNode] = this.getClosestNodeFromList(currentList);\n      this.currentNodeFromEnd = closestNode;\n      closestNode.isVisitedFromEnd = true;\n    }\n\n    // algorithm will do iteration regardless of if it's done or not\n    this.visitNodeFromList(closestNode, currentList);\n\n    currentList.splice(index, 1);\n\n    this.iterationCount += 1;\n  }\n\n  getClosestNodeFromList = (nodeList: Node[]) => {\n    let closestNode = nodeList[0];\n    let closestNodeIndex = undefined;\n\n    for (let [index, node] of nodeList.entries()) {\n      if (node.pathDistance < closestNode.pathDistance) {\n          closestNode = node;\n          closestNodeIndex = index;\n      }\n    }\n\n    return [closestNodeIndex, closestNode];\n  }\n\n  visitNodeFromList = (nodeToVisit: Node, unvisitedList: Node[]) => {\n    let unvisitedNeighbours = this.getUnvisitedNeighbours(nodeToVisit);\n\n    for (let { node: neighbour, relativeDistance } of unvisitedNeighbours) {\n      let potentialDistance = nodeToVisit.pathDistance + relativeDistance;\n\n      if (neighbour.pathDistance > potentialDistance) {\n        neighbour.pathDistance = potentialDistance;\n        neighbour.parent = nodeToVisit;\n\n        // if (!this.unvisitedNodes.includes(neighbour)) {\n        //   this.unvisitedNodes.push(neighbour);\n        //   neighbour.isProspected = true;\n        // }\n        unvisitedList.push(neighbour);\n        neighbour.isProspected = true;\n      }\n    }\n  }\n\n  override checkIfDone = (): { isDone: boolean, reason?: string } => { \n    if (this.currentNode.isVisited && this.currentNode.isVisitedFromEnd) {\n      return { isDone: true, reason: 'reached end' };\n    } else if (this.unvisitedNodes.length == 0 &&\n       this.unvisitedNodesFromEnd.length == 0) {\n      return { isDone: true, reason: 'no solution' };\n    } else {\n      return { isDone: false };\n    }\n  }\n\n  override tracePath = (nodeToTrace?: Node): Node[] => {\n    let pathNodes = [];\n\n    nodeToTrace = this.startingNode;\n    while (nodeToTrace.parent) {\n      pathNodes.push(nodeToTrace);\n      nodeToTrace = nodeToTrace.parent;\n    }\n\n    nodeToTrace = this.endingNode;\n    while (nodeToTrace.parent) {\n      pathNodes.push(nodeToTrace);\n      nodeToTrace = nodeToTrace.parent;\n    }\n\n    return pathNodes;\n  };\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}