{"ast":null,"code":"var _class;\nimport { Pathfinder } from './pathfinder';\nimport * as i0 from \"@angular/core\";\nexport class DijkstraService extends Pathfinder {\n  constructor() {\n    super(...arguments);\n    this.doIteration = () => {\n      let [index, closestNode] = this.getClosestNode();\n      this.currentNode = closestNode;\n      // algorithm will do iteration regardless of if it's done or not\n      this.visitNode(closestNode);\n      this.unvisitedNodes.splice(index, 1);\n      this.iterationCount += 1;\n      return closestNode;\n    };\n    // get node of least distance\n    this.getClosestNode = () => {\n      let closestNode = this.unvisitedNodes[0];\n      let closestNodeIndex = undefined;\n      for (let [index, node] of this.unvisitedNodes.entries()) {\n        if (node.pathDistance < closestNode.pathDistance) {\n          closestNode = node;\n          closestNodeIndex = index;\n        }\n      }\n      return [closestNodeIndex, closestNode];\n    };\n    // add all adjacent nodes that haven't been visited to unvisitedNodes list\n    // assign adjacent nodes distances and set current node to visited \n    this.visitNode = nodeToVisit => {\n      let unvisitedNeighbours = this.getUnvisitedNeighbours(nodeToVisit);\n      for (let {\n        node: neighbour,\n        relativeDistance\n      } of unvisitedNeighbours) {\n        let potentialDistance = nodeToVisit.pathDistance + relativeDistance;\n        if (neighbour.pathDistance > potentialDistance) {\n          neighbour.pathDistance = potentialDistance;\n          neighbour.parent = nodeToVisit;\n          if (!this.unvisitedNodes.includes(neighbour)) {\n            this.unvisitedNodes.push(neighbour);\n            neighbour.isProspected = true;\n          }\n        }\n      }\n      nodeToVisit.isVisited = true;\n    };\n  }\n}\n_class = DijkstraService;\n_class.ɵfac = /*@__PURE__*/function () {\n  let ɵDijkstraService_BaseFactory;\n  return function DijkstraService_Factory(t) {\n    return (ɵDijkstraService_BaseFactory || (ɵDijkstraService_BaseFactory = i0.ɵɵgetInheritedFactory(_class)))(t || _class);\n  };\n}();\n_class.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n  token: _class,\n  factory: _class.ɵfac,\n  providedIn: 'root'\n});","map":{"version":3,"names":["Pathfinder","DijkstraService","constructor","doIteration","index","closestNode","getClosestNode","currentNode","visitNode","unvisitedNodes","splice","iterationCount","closestNodeIndex","undefined","node","entries","pathDistance","nodeToVisit","unvisitedNeighbours","getUnvisitedNeighbours","neighbour","relativeDistance","potentialDistance","parent","includes","push","isProspected","isVisited","t","factory","ɵfac","providedIn"],"sources":["C:\\Users\\Miguel\\Desktop\\algorithm-visualizer\\src\\app\\node-map\\services\\algorithms\\dijkstra.service.ts"],"sourcesContent":["import { Injectable } from '@angular/core';\nimport { Pathfinder } from './pathfinder';\nimport { Node } from 'src/app/node/node';\n\n@Injectable({\n  providedIn: 'root'\n})\nexport class DijkstraService extends Pathfinder {\n\n  override doIteration = (): undefined | Node => {\n    let [index, closestNode] = this.getClosestNode();\n    this.currentNode = closestNode;\n\n    // algorithm will do iteration regardless of if it's done or not\n    this.visitNode(closestNode);\n    this.unvisitedNodes.splice(index, 1);\n\n    this.iterationCount += 1;\n    return closestNode;\n  }\n\n  // get node of least distance\n  getClosestNode = () => {\n    let closestNode = this.unvisitedNodes[0];\n    let closestNodeIndex = undefined;\n\n    for (let [index, node] of this.unvisitedNodes.entries()) {\n      if (node.pathDistance < closestNode.pathDistance) {\n          closestNode = node;\n          closestNodeIndex = index;\n      }\n    }\n\n    return [closestNodeIndex, closestNode];\n  }\n\n  // add all adjacent nodes that haven't been visited to unvisitedNodes list\n  // assign adjacent nodes distances and set current node to visited \n  visitNode = (nodeToVisit: Node) => {\n    let unvisitedNeighbours = this.getUnvisitedNeighbours(nodeToVisit);\n\n    for (let { node: neighbour, relativeDistance } of unvisitedNeighbours) {\n      let potentialDistance = nodeToVisit.pathDistance + relativeDistance;\n\n      if (neighbour.pathDistance > potentialDistance) {\n        neighbour.pathDistance = potentialDistance;\n        neighbour.parent = nodeToVisit;\n\n        if (!this.unvisitedNodes.includes(neighbour)) {\n          this.unvisitedNodes.push(neighbour);\n          neighbour.isProspected = true;\n        }\n      }\n    }\n\n    nodeToVisit.isVisited = true;\n  }\n}\n"],"mappings":";AACA,SAASA,UAAU,QAAQ,cAAc;;AAMzC,OAAM,MAAOC,eAAgB,SAAQD,UAAU;EAH/CE,YAAA;;IAKW,KAAAC,WAAW,GAAG,MAAuB;MAC5C,IAAI,CAACC,KAAK,EAAEC,WAAW,CAAC,GAAG,IAAI,CAACC,cAAc,EAAE;MAChD,IAAI,CAACC,WAAW,GAAGF,WAAW;MAE9B;MACA,IAAI,CAACG,SAAS,CAACH,WAAW,CAAC;MAC3B,IAAI,CAACI,cAAc,CAACC,MAAM,CAACN,KAAK,EAAE,CAAC,CAAC;MAEpC,IAAI,CAACO,cAAc,IAAI,CAAC;MACxB,OAAON,WAAW;IACpB,CAAC;IAED;IACA,KAAAC,cAAc,GAAG,MAAK;MACpB,IAAID,WAAW,GAAG,IAAI,CAACI,cAAc,CAAC,CAAC,CAAC;MACxC,IAAIG,gBAAgB,GAAGC,SAAS;MAEhC,KAAK,IAAI,CAACT,KAAK,EAAEU,IAAI,CAAC,IAAI,IAAI,CAACL,cAAc,CAACM,OAAO,EAAE,EAAE;QACvD,IAAID,IAAI,CAACE,YAAY,GAAGX,WAAW,CAACW,YAAY,EAAE;UAC9CX,WAAW,GAAGS,IAAI;UAClBF,gBAAgB,GAAGR,KAAK;;;MAI9B,OAAO,CAACQ,gBAAgB,EAAEP,WAAW,CAAC;IACxC,CAAC;IAED;IACA;IACA,KAAAG,SAAS,GAAIS,WAAiB,IAAI;MAChC,IAAIC,mBAAmB,GAAG,IAAI,CAACC,sBAAsB,CAACF,WAAW,CAAC;MAElE,KAAK,IAAI;QAAEH,IAAI,EAAEM,SAAS;QAAEC;MAAgB,CAAE,IAAIH,mBAAmB,EAAE;QACrE,IAAII,iBAAiB,GAAGL,WAAW,CAACD,YAAY,GAAGK,gBAAgB;QAEnE,IAAID,SAAS,CAACJ,YAAY,GAAGM,iBAAiB,EAAE;UAC9CF,SAAS,CAACJ,YAAY,GAAGM,iBAAiB;UAC1CF,SAAS,CAACG,MAAM,GAAGN,WAAW;UAE9B,IAAI,CAAC,IAAI,CAACR,cAAc,CAACe,QAAQ,CAACJ,SAAS,CAAC,EAAE;YAC5C,IAAI,CAACX,cAAc,CAACgB,IAAI,CAACL,SAAS,CAAC;YACnCA,SAAS,CAACM,YAAY,GAAG,IAAI;;;;MAKnCT,WAAW,CAACU,SAAS,GAAG,IAAI;IAC9B,CAAC;;;SAjDU1B,eAAgB;;;;qGAAhBA,MAAe,IAAA2B,CAAA,IAAf3B,MAAe;EAAA;AAAA;;SAAfA,MAAe;EAAA4B,OAAA,EAAf5B,MAAe,CAAA6B,IAAA;EAAAC,UAAA,EAFd;AAAM"},"metadata":{},"sourceType":"module","externalDependencies":[]}