{"ast":null,"code":"var _class;\nimport * as i0 from \"@angular/core\";\nexport class NodeMapService {\n  constructor() {\n    this.generateMap = (mapWidth, mapHeight) => {\n      let map = [];\n      // generate nodes\n      for (let i = 0; i < mapHeight; i++) {\n        map.push(...this.generateRow(mapWidth, i));\n      }\n      // assings neighbours for each node IMPLEMENT DISTANCE IF NEEDED\n      for (let [index, node] of map.entries()) {\n        let newNeighbours = [];\n        let isRightAvailable = node.xPosition + 1 < mapWidth;\n        let isLeftAvailable = node.xPosition - 1 >= 0;\n        let isBelowAvailable = node.yPosition + 1 < mapHeight;\n        let isAboveAvailable = node.yPosition - 1 >= 0;\n        // normal neighbours\n        if (isRightAvailable) {\n          newNeighbours.push(map[index + 1]); // index + 1 reaches the neighbour to the right on the grid\n        }\n\n        if (isLeftAvailable) {\n          newNeighbours.push(map[index - 1]); // index - 1 reaches the neighbour to the left on the grid\n        }\n\n        if (isBelowAvailable) {\n          newNeighbours.push(map[index + mapWidth]); // index + mapWidth reaches the neighbour below on the grid\n        }\n\n        if (isAboveAvailable) {\n          newNeighbours.push(map[index - mapWidth]); // index + mapWidth reaches the neighbour above on the grid\n        }\n        // diagonal neighbours\n        if (isRightAvailable || isBelowAvailable) {\n          newNeighbours.push(map[index + 1 + mapWidth]); // index + 1 + mapWidth reaches the SE neighbour on the grid\n        }\n\n        if (isRightAvailable || isAboveAvailable) {\n          newNeighbours.push(map[index + 1 - mapWidth]); // index + 1 - mapWidth reaches the NE neighbour on the grid\n        }\n\n        if (isLeftAvailable || isBelowAvailable) {\n          newNeighbours.push(map[index - 1 + mapWidth]); // index - 1 + mapWidth reaches the SW neighbour on the grid\n        }\n\n        if (isLeftAvailable || isAboveAvailable) {\n          newNeighbours.push(map[index - 1 - mapWidth]); // index - 1 + mapWidth reaches the NW neighbour on the grid\n        }\n\n        node.neighbours = newNeighbours;\n      }\n      return map;\n    };\n    this.generateRow = (width, yCoord) => {\n      let row = [];\n      for (let xCoord = 0; xCoord < width; xCoord++) {\n        let newNode = {\n          weight: 1,\n          parent: undefined,\n          distance: Infinity,\n          wasVisited: false,\n          isBlocked: false,\n          xPosition: xCoord,\n          yPosition: yCoord\n        };\n        row.push(newNode);\n      }\n      return row;\n    };\n  }\n}\n_class = NodeMapService;\n_class.ɵfac = function NodeMapService_Factory(t) {\n  return new (t || _class)();\n};\n_class.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n  token: _class,\n  factory: _class.ɵfac,\n  providedIn: 'root'\n});","map":{"version":3,"names":["NodeMapService","constructor","generateMap","mapWidth","mapHeight","map","i","push","generateRow","index","node","entries","newNeighbours","isRightAvailable","xPosition","isLeftAvailable","isBelowAvailable","yPosition","isAboveAvailable","neighbours","width","yCoord","row","xCoord","newNode","weight","parent","undefined","distance","Infinity","wasVisited","isBlocked","factory","ɵfac","providedIn"],"sources":["C:\\Users\\Miguel\\Desktop\\algorithm-visualizer\\src\\app\\node-map\\services\\node-map.service.ts"],"sourcesContent":["import { Injectable } from '@angular/core';\r\nimport { Node } from '../../node/node';\r\n\r\n@Injectable({\r\n  providedIn: 'root'\r\n})\r\nexport class NodeMapService {\r\n  generateMap = (mapWidth: number, mapHeight: number) => {\r\n    let map: Node[] = [];\r\n\r\n    // generate nodes\r\n    for (let i = 0; i < mapHeight; i++) {\r\n      map.push(...this.generateRow(mapWidth, i));\r\n    } \r\n\r\n    // assings neighbours for each node IMPLEMENT DISTANCE IF NEEDED\r\n    for (let [index, node] of map.entries()) {\r\n      let newNeighbours: Node[] = [];\r\n\r\n      let isRightAvailable: boolean = node.xPosition + 1 < mapWidth;\r\n      let isLeftAvailable: boolean = node.xPosition - 1 >= 0;\r\n      let isBelowAvailable: boolean = node.yPosition + 1 < mapHeight;\r\n      let isAboveAvailable: boolean = node.yPosition - 1 >= 0;\r\n\r\n      // normal neighbours\r\n      if (isRightAvailable) {\r\n        newNeighbours.push(map[index + 1]); // index + 1 reaches the neighbour to the right on the grid\r\n      }\r\n      if (isLeftAvailable) {\r\n        newNeighbours.push(map[index - 1]); // index - 1 reaches the neighbour to the left on the grid\r\n      }\r\n      if (isBelowAvailable) {\r\n        newNeighbours.push(map[index + mapWidth]); // index + mapWidth reaches the neighbour below on the grid\r\n      }\r\n      if (isAboveAvailable) {\r\n        newNeighbours.push(map[index - mapWidth]);  // index + mapWidth reaches the neighbour above on the grid\r\n      }\r\n\r\n      // diagonal neighbours\r\n      if (isRightAvailable || isBelowAvailable) {\r\n        newNeighbours.push(map[index + 1 + mapWidth]); // index + 1 + mapWidth reaches the SE neighbour on the grid\r\n      }\r\n      if (isRightAvailable || isAboveAvailable) {\r\n        newNeighbours.push(map[index + 1 - mapWidth]); // index + 1 - mapWidth reaches the NE neighbour on the grid\r\n      }\r\n      if (isLeftAvailable || isBelowAvailable) {\r\n        newNeighbours.push(map[index - 1 + mapWidth]); // index - 1 + mapWidth reaches the SW neighbour on the grid\r\n      }\r\n      if (isLeftAvailable || isAboveAvailable) {\r\n        newNeighbours.push(map[index - 1 - mapWidth]); // index - 1 + mapWidth reaches the NW neighbour on the grid\r\n      }\r\n\r\n      node.neighbours = newNeighbours;\r\n    }\r\n\r\n    return map;\r\n  }\r\n\r\n  generateRow = (width: number, yCoord: number): Node[] => {\r\n    let row: Node[] = [];\r\n\r\n    for (let xCoord = 0; xCoord < width; xCoord++) {\r\n      let newNode: Node = {\r\n        weight: 1,\r\n        parent: undefined,\r\n        distance: Infinity,\r\n        wasVisited: false,\r\n        isBlocked: false,\r\n        xPosition: xCoord,\r\n        yPosition: yCoord\r\n      }\r\n\r\n      row.push(newNode);\r\n    }\r\n\r\n    return row;\r\n  }\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}