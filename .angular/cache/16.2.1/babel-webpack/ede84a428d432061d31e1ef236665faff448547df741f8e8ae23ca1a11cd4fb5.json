{"ast":null,"code":"var _class;\nimport * as i0 from \"@angular/core\";\nexport class NodeMapService {\n  constructor() {\n    this.generateMap = (mapWidth, mapHeight) => {\n      let map = [];\n      // generate nodes\n      for (let i = 0; i < mapHeight; i++) {\n        map.push(...this.generateRow(mapWidth, i));\n      }\n      // assings neighbours for each node IMPLEMENT DISTANCE IF NEEDED\n      for (let [index, node] of map.entries()) {\n        let newNeighbours = [];\n        if (node.xPosition + 1 < mapWidth) {\n          newNeighbours.push(map[index + 1]); // index + 1 reaches the neighbour to the right\n        }\n\n        if (node.xPosition - 1 >= 0) {\n          newNeighbours.push(map[index - 1]); // index - 1 reaches the neighbour to the left\n        }\n\n        if (node.yPosition + 1 < mapHeight) {\n          newNeighbours.push(map[index + mapWidth]); // index + mapwidth reaches the neighbour below \n        }\n\n        if (node.yPosition - 1 >= 0) {\n          newNeighbours.push(map[index - mapWidth]); // index + mapwidth reaches the neighbour above\n        }\n\n        node.neighbours = newNeighbours;\n      }\n      return map;\n    };\n    this.generateRow = (width, yCoord) => {\n      let row = [];\n      for (let xCoord = 0; xCoord < width; xCoord++) {\n        let newNode = {\n          weight: 1,\n          parent: undefined,\n          distance: Infinity,\n          wasVisited: false,\n          isBlocked: false,\n          xPosition: xCoord,\n          yPosition: yCoord\n        };\n        row.push(newNode);\n      }\n      return row;\n    };\n  }\n}\n_class = NodeMapService;\n_class.ɵfac = function NodeMapService_Factory(t) {\n  return new (t || _class)();\n};\n_class.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n  token: _class,\n  factory: _class.ɵfac,\n  providedIn: 'root'\n});","map":{"version":3,"names":["NodeMapService","constructor","generateMap","mapWidth","mapHeight","map","i","push","generateRow","index","node","entries","newNeighbours","xPosition","yPosition","neighbours","width","yCoord","row","xCoord","newNode","weight","parent","undefined","distance","Infinity","wasVisited","isBlocked","factory","ɵfac","providedIn"],"sources":["C:\\Users\\Miguel\\Desktop\\algorithm-visualizer\\src\\app\\node-map\\services\\node-map.service.ts"],"sourcesContent":["import { Injectable } from '@angular/core';\r\nimport { Node } from '../../node/node';\r\n\r\n@Injectable({\r\n  providedIn: 'root'\r\n})\r\nexport class NodeMapService {\r\n  generateMap = (mapWidth: number, mapHeight: number) => {\r\n    let map: Node[] = [];\r\n\r\n    // generate nodes\r\n    for (let i = 0; i < mapHeight; i++) {\r\n      map.push(...this.generateRow(mapWidth, i));\r\n    } \r\n\r\n    // assings neighbours for each node IMPLEMENT DISTANCE IF NEEDED\r\n    for (let [index, node] of map.entries()) {\r\n      let newNeighbours: Node[] = [];\r\n\r\n      if (node.xPosition + 1 < mapWidth) {\r\n        newNeighbours.push(map[index + 1]); // index + 1 reaches the neighbour to the right\r\n      }\r\n      if (node.xPosition - 1 >= 0) {\r\n        newNeighbours.push(map[index - 1]); // index - 1 reaches the neighbour to the left\r\n      }\r\n      if (node.yPosition + 1 < mapHeight) {\r\n        newNeighbours.push(map[index + mapWidth]); // index + mapwidth reaches the neighbour below \r\n      }\r\n      if (node.yPosition - 1 >= 0) {\r\n        newNeighbours.push(map[index - mapWidth]);  // index + mapwidth reaches the neighbour above\r\n      }\r\n\r\n      node.neighbours = newNeighbours;\r\n    }\r\n\r\n    return map;\r\n  }\r\n\r\n  generateRow = (width: number, yCoord: number): Node[] => {\r\n    let row: Node[] = [];\r\n\r\n    for (let xCoord = 0; xCoord < width; xCoord++) {\r\n      let newNode: Node = {\r\n        weight: 1,\r\n        parent: undefined,\r\n        distance: Infinity,\r\n        wasVisited: false,\r\n        isBlocked: false,\r\n        xPosition: xCoord,\r\n        yPosition: yCoord\r\n      }\r\n\r\n      row.push(newNode);\r\n    }\r\n\r\n    return row;\r\n  }\r\n}\r\n"],"mappings":";;AAMA,OAAM,MAAOA,cAAc;EAH3BC,YAAA;IAIE,KAAAC,WAAW,GAAG,CAACC,QAAgB,EAAEC,SAAiB,KAAI;MACpD,IAAIC,GAAG,GAAW,EAAE;MAEpB;MACA,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGF,SAAS,EAAEE,CAAC,EAAE,EAAE;QAClCD,GAAG,CAACE,IAAI,CAAC,GAAG,IAAI,CAACC,WAAW,CAACL,QAAQ,EAAEG,CAAC,CAAC,CAAC;;MAG5C;MACA,KAAK,IAAI,CAACG,KAAK,EAAEC,IAAI,CAAC,IAAIL,GAAG,CAACM,OAAO,EAAE,EAAE;QACvC,IAAIC,aAAa,GAAW,EAAE;QAE9B,IAAIF,IAAI,CAACG,SAAS,GAAG,CAAC,GAAGV,QAAQ,EAAE;UACjCS,aAAa,CAACL,IAAI,CAACF,GAAG,CAACI,KAAK,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC;;;QAEtC,IAAIC,IAAI,CAACG,SAAS,GAAG,CAAC,IAAI,CAAC,EAAE;UAC3BD,aAAa,CAACL,IAAI,CAACF,GAAG,CAACI,KAAK,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC;;;QAEtC,IAAIC,IAAI,CAACI,SAAS,GAAG,CAAC,GAAGV,SAAS,EAAE;UAClCQ,aAAa,CAACL,IAAI,CAACF,GAAG,CAACI,KAAK,GAAGN,QAAQ,CAAC,CAAC,CAAC,CAAC;;;QAE7C,IAAIO,IAAI,CAACI,SAAS,GAAG,CAAC,IAAI,CAAC,EAAE;UAC3BF,aAAa,CAACL,IAAI,CAACF,GAAG,CAACI,KAAK,GAAGN,QAAQ,CAAC,CAAC,CAAC,CAAE;;;QAG9CO,IAAI,CAACK,UAAU,GAAGH,aAAa;;MAGjC,OAAOP,GAAG;IACZ,CAAC;IAED,KAAAG,WAAW,GAAG,CAACQ,KAAa,EAAEC,MAAc,KAAY;MACtD,IAAIC,GAAG,GAAW,EAAE;MAEpB,KAAK,IAAIC,MAAM,GAAG,CAAC,EAAEA,MAAM,GAAGH,KAAK,EAAEG,MAAM,EAAE,EAAE;QAC7C,IAAIC,OAAO,GAAS;UAClBC,MAAM,EAAE,CAAC;UACTC,MAAM,EAAEC,SAAS;UACjBC,QAAQ,EAAEC,QAAQ;UAClBC,UAAU,EAAE,KAAK;UACjBC,SAAS,EAAE,KAAK;UAChBd,SAAS,EAAEM,MAAM;UACjBL,SAAS,EAAEG;SACZ;QAEDC,GAAG,CAACX,IAAI,CAACa,OAAO,CAAC;;MAGnB,OAAOF,GAAG;IACZ,CAAC;;;SAlDUlB,cAAc;;mBAAdA,MAAc;AAAA;;SAAdA,MAAc;EAAA4B,OAAA,EAAd5B,MAAc,CAAA6B,IAAA;EAAAC,UAAA,EAFb;AAAM"},"metadata":{},"sourceType":"module","externalDependencies":[]}