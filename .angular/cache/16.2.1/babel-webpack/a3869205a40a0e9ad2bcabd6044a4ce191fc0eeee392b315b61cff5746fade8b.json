{"ast":null,"code":"var _class;\nimport { Pathfinder } from './pathfinder';\nimport * as i0 from \"@angular/core\";\n// bidirectional swarm works the same way as dijkstra\nexport class BidirectionalService extends Pathfinder {\n  constructor() {\n    super(...arguments);\n    this.setAlgorithmValues = (start, end) => {\n      // set everything the same way as other algorithms\n      super.setAlgorithmValues(start, end);\n      this.startingNode.isVisitedFromEnd = false;\n      this.endingNode.pathDistanceFromEnd = 0;\n      this.currentNodeFromEnd = end;\n      this.unvisitedNodesFromEnd = [end];\n    };\n    this.doIteration = () => {\n      // this block ensures that the algorithm goes back and forth \n      // from searching from the start to end\n      let currentList;\n      if (this.iterationCount % 2 == 0) {\n        currentList = this.unvisitedNodes;\n        var [index, closestNode] = this.getClosestNodeFromList(currentList);\n        this.visitNodeFromStart(closestNode);\n        this.currentNode = closestNode;\n        closestNode.isVisited = true;\n      } else {\n        currentList = this.unvisitedNodesFromEnd;\n        var [index, closestNode] = this.getClosestNodeFromList(currentList);\n        this.visitNodeFromEnd(closestNode);\n        this.currentNodeFromEnd = closestNode;\n        closestNode.isVisitedFromEnd = true;\n      }\n      currentList.splice(index, 1);\n      this.iterationCount += 1;\n    };\n    this.getClosestNodeFromList = nodeList => {\n      let closestNode = nodeList[0];\n      let closestNodeIndex = undefined;\n      for (let [index, node] of nodeList.entries()) {\n        if (node.pathDistance < closestNode.pathDistance) {\n          closestNode = node;\n          closestNodeIndex = index;\n        }\n      }\n      return [closestNodeIndex, closestNode];\n    };\n    this.visitNodeFromStart = nodeToVisit => {\n      let unvisitedNeighbours = this.getUnvisitedNeighbours(nodeToVisit);\n      for (let {\n        node: neighbour,\n        relativeDistance\n      } of unvisitedNeighbours) {\n        let potentialDistance = nodeToVisit.pathDistance + relativeDistance;\n        if (neighbour.pathDistance > potentialDistance) {\n          neighbour.pathDistance = potentialDistance;\n          neighbour.parent = nodeToVisit;\n          this.unvisitedNodes.push(neighbour);\n          neighbour.isProspected = true;\n        }\n      }\n      nodeToVisit.isVisited = true;\n    };\n    this.visitNodeFromEnd = nodeToVisit => {\n      let unvisitedNeighbours = this.getUnvisitedFromEndNeighbours(nodeToVisit);\n      for (let {\n        node: neighbour,\n        relativeDistance\n      } of unvisitedNeighbours) {\n        let potentialDistance = nodeToVisit.pathDistanceFromEnd + relativeDistance;\n        if (neighbour.pathDistanceFromEnd > potentialDistance) {\n          neighbour.pathDistanceFromEnd = potentialDistance;\n          neighbour.parent = nodeToVisit;\n          this.unvisitedNodesFromEnd.push(neighbour);\n          neighbour.isProspected = true;\n        }\n      }\n      nodeToVisit.isVisitedFromEnd = true;\n    };\n    this.getUnvisitedFromEndNeighbours = node => {\n      let nodeNeighbours = node.neighbours;\n      return [...nodeNeighbours.filter(neighbour => !neighbour.node.isBlocked && !neighbour.node.isVisitedFromEnd)];\n    };\n    this.checkIfDone = () => {\n      if (this.currentNode == this.endingNode) {\n        return {\n          isDone: true,\n          reason: 'reached end'\n        };\n      } else if (this.unvisitedNodes.length == 0 && this.unvisitedNodesFromEnd.length == 0) {\n        return {\n          isDone: true,\n          reason: 'no solution'\n        };\n      } else {\n        return {\n          isDone: false\n        };\n      }\n    };\n    this.tracePath = nodeToTrace => {\n      let pathNodes = [];\n      let node = this.currentNode;\n      while (node.parent != this.startingNode) {\n        pathNodes.push(node);\n        node = node.parent;\n      }\n      node = this.currentNodeFromEnd;\n      while (node.parent != this.endingNode) {\n        pathNodes.push(node);\n        node = node.parent;\n      }\n      return pathNodes;\n    };\n  }\n}\n_class = BidirectionalService;\n_class.ɵfac = /*@__PURE__*/function () {\n  let ɵBidirectionalService_BaseFactory;\n  return function BidirectionalService_Factory(t) {\n    return (ɵBidirectionalService_BaseFactory || (ɵBidirectionalService_BaseFactory = i0.ɵɵgetInheritedFactory(_class)))(t || _class);\n  };\n}();\n_class.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n  token: _class,\n  factory: _class.ɵfac,\n  providedIn: 'root'\n});","map":{"version":3,"names":["Pathfinder","BidirectionalService","constructor","setAlgorithmValues","start","end","startingNode","isVisitedFromEnd","endingNode","pathDistanceFromEnd","currentNodeFromEnd","unvisitedNodesFromEnd","doIteration","currentList","iterationCount","unvisitedNodes","index","closestNode","getClosestNodeFromList","visitNodeFromStart","currentNode","isVisited","visitNodeFromEnd","splice","nodeList","closestNodeIndex","undefined","node","entries","pathDistance","nodeToVisit","unvisitedNeighbours","getUnvisitedNeighbours","neighbour","relativeDistance","potentialDistance","parent","push","isProspected","getUnvisitedFromEndNeighbours","nodeNeighbours","neighbours","filter","isBlocked","checkIfDone","isDone","reason","length","tracePath","nodeToTrace","pathNodes","t","factory","ɵfac","providedIn"],"sources":["C:\\Users\\Miguel\\Desktop\\algorithm-visualizer\\src\\app\\node-map\\services\\algorithms\\bidirectional.service.ts"],"sourcesContent":["import { Injectable } from '@angular/core';\nimport { Node } from 'src/app/node/node';\nimport { Pathfinder } from './pathfinder';\n\n@Injectable({\n  providedIn: 'root'\n})\n// bidirectional swarm works the same way as dijkstra\nexport class BidirectionalService extends Pathfinder {\n\n  currentNodeFromEnd: Node;\n  unvisitedNodesFromEnd: Node[];\n\n  override setAlgorithmValues = (start: Node, end: Node) => {\n    // set everything the same way as other algorithms\n    super.setAlgorithmValues(start, end);\n    this.startingNode.isVisitedFromEnd = false;\n    this.endingNode.pathDistanceFromEnd = 0;\n    this.currentNodeFromEnd = end;\n    this.unvisitedNodesFromEnd = [end];\n  };\n\n  override doIteration = (): void => {\n    // this block ensures that the algorithm goes back and forth \n    // from searching from the start to end\n    let currentList: Node[];\n    if (this.iterationCount % 2 == 0) {\n      currentList = this.unvisitedNodes;\n      var [index, closestNode] = this.getClosestNodeFromList(currentList);\n      this.visitNodeFromStart(closestNode);\n      this.currentNode = closestNode;\n      closestNode.isVisited = true;\n    } else {\n      currentList = this.unvisitedNodesFromEnd;\n      var [index, closestNode] = this.getClosestNodeFromList(currentList);\n      this.visitNodeFromEnd(closestNode);\n      this.currentNodeFromEnd = closestNode;\n      closestNode.isVisitedFromEnd = true;\n    }\n\n    currentList.splice(index, 1);\n\n    this.iterationCount += 1;\n  }\n\n  getClosestNodeFromList = (nodeList: Node[]) => {\n    let closestNode = nodeList[0];\n    let closestNodeIndex = undefined;\n\n    for (let [index, node] of nodeList.entries()) {\n      if (node.pathDistance < closestNode.pathDistance) {\n          closestNode = node;\n          closestNodeIndex = index;\n      }\n    }\n\n    return [closestNodeIndex, closestNode];\n  }\n\n  visitNodeFromStart = (nodeToVisit: Node) => {\n    let unvisitedNeighbours = this.getUnvisitedNeighbours(nodeToVisit);\n\n    for (let { node: neighbour, relativeDistance } of unvisitedNeighbours) {\n      let potentialDistance = nodeToVisit.pathDistance + relativeDistance;\n\n      if (neighbour.pathDistance > potentialDistance) {\n        neighbour.pathDistance = potentialDistance;\n        neighbour.parent = nodeToVisit;\n\n        this.unvisitedNodes.push(neighbour);\n        neighbour.isProspected = true;\n      }\n    }\n\n    nodeToVisit.isVisited = true;\n  }\n\n  visitNodeFromEnd = (nodeToVisit: Node) => {\n    let unvisitedNeighbours = this.getUnvisitedFromEndNeighbours(nodeToVisit);\n\n    for (let { node: neighbour, relativeDistance } of unvisitedNeighbours) {\n      let potentialDistance = nodeToVisit.pathDistanceFromEnd + relativeDistance;\n\n      if (neighbour.pathDistanceFromEnd > potentialDistance) {\n        neighbour.pathDistanceFromEnd = potentialDistance;\n        neighbour.parent = nodeToVisit;\n\n        this.unvisitedNodesFromEnd.push(neighbour);\n        neighbour.isProspected = true;\n      }\n    }\n\n    nodeToVisit.isVisitedFromEnd = true;\n  }\n\n  getUnvisitedFromEndNeighbours = (node: Node) => {\n    let nodeNeighbours = node.neighbours\n\n    return [...nodeNeighbours.filter((neighbour) => !neighbour.node.isBlocked && !neighbour.node.isVisitedFromEnd)];\n  };\n\n  override checkIfDone = (): { isDone: boolean, reason?: string } => { \n    if (this.currentNode == this.endingNode) {\n      return { isDone: true, reason: 'reached end' };\n    } else if (this.unvisitedNodes.length == 0 &&\n       this.unvisitedNodesFromEnd.length == 0) {\n      return { isDone: true, reason: 'no solution' };\n    } else {\n      return { isDone: false };\n    }\n  }\n\n  override tracePath = (nodeToTrace?: Node): Node[] => {\n    let pathNodes = [];\n\n    let node = this.currentNode;\n    while (node.parent != this.startingNode) {\n      pathNodes.push(node);\n      node = node.parent;\n    }\n\n    node = this.currentNodeFromEnd;\n    while (node.parent != this.endingNode) {\n      pathNodes.push(node);\n      node = node.parent;\n    }\n\n    return pathNodes;\n  };\n}\n"],"mappings":";AAEA,SAASA,UAAU,QAAQ,cAAc;;AAKzC;AACA,OAAM,MAAOC,oBAAqB,SAAQD,UAAU;EAJpDE,YAAA;;IASW,KAAAC,kBAAkB,GAAG,CAACC,KAAW,EAAEC,GAAS,KAAI;MACvD;MACA,KAAK,CAACF,kBAAkB,CAACC,KAAK,EAAEC,GAAG,CAAC;MACpC,IAAI,CAACC,YAAY,CAACC,gBAAgB,GAAG,KAAK;MAC1C,IAAI,CAACC,UAAU,CAACC,mBAAmB,GAAG,CAAC;MACvC,IAAI,CAACC,kBAAkB,GAAGL,GAAG;MAC7B,IAAI,CAACM,qBAAqB,GAAG,CAACN,GAAG,CAAC;IACpC,CAAC;IAEQ,KAAAO,WAAW,GAAG,MAAW;MAChC;MACA;MACA,IAAIC,WAAmB;MACvB,IAAI,IAAI,CAACC,cAAc,GAAG,CAAC,IAAI,CAAC,EAAE;QAChCD,WAAW,GAAG,IAAI,CAACE,cAAc;QACjC,IAAI,CAACC,KAAK,EAAEC,WAAW,CAAC,GAAG,IAAI,CAACC,sBAAsB,CAACL,WAAW,CAAC;QACnE,IAAI,CAACM,kBAAkB,CAACF,WAAW,CAAC;QACpC,IAAI,CAACG,WAAW,GAAGH,WAAW;QAC9BA,WAAW,CAACI,SAAS,GAAG,IAAI;OAC7B,MAAM;QACLR,WAAW,GAAG,IAAI,CAACF,qBAAqB;QACxC,IAAI,CAACK,KAAK,EAAEC,WAAW,CAAC,GAAG,IAAI,CAACC,sBAAsB,CAACL,WAAW,CAAC;QACnE,IAAI,CAACS,gBAAgB,CAACL,WAAW,CAAC;QAClC,IAAI,CAACP,kBAAkB,GAAGO,WAAW;QACrCA,WAAW,CAACV,gBAAgB,GAAG,IAAI;;MAGrCM,WAAW,CAACU,MAAM,CAACP,KAAK,EAAE,CAAC,CAAC;MAE5B,IAAI,CAACF,cAAc,IAAI,CAAC;IAC1B,CAAC;IAED,KAAAI,sBAAsB,GAAIM,QAAgB,IAAI;MAC5C,IAAIP,WAAW,GAAGO,QAAQ,CAAC,CAAC,CAAC;MAC7B,IAAIC,gBAAgB,GAAGC,SAAS;MAEhC,KAAK,IAAI,CAACV,KAAK,EAAEW,IAAI,CAAC,IAAIH,QAAQ,CAACI,OAAO,EAAE,EAAE;QAC5C,IAAID,IAAI,CAACE,YAAY,GAAGZ,WAAW,CAACY,YAAY,EAAE;UAC9CZ,WAAW,GAAGU,IAAI;UAClBF,gBAAgB,GAAGT,KAAK;;;MAI9B,OAAO,CAACS,gBAAgB,EAAER,WAAW,CAAC;IACxC,CAAC;IAED,KAAAE,kBAAkB,GAAIW,WAAiB,IAAI;MACzC,IAAIC,mBAAmB,GAAG,IAAI,CAACC,sBAAsB,CAACF,WAAW,CAAC;MAElE,KAAK,IAAI;QAAEH,IAAI,EAAEM,SAAS;QAAEC;MAAgB,CAAE,IAAIH,mBAAmB,EAAE;QACrE,IAAII,iBAAiB,GAAGL,WAAW,CAACD,YAAY,GAAGK,gBAAgB;QAEnE,IAAID,SAAS,CAACJ,YAAY,GAAGM,iBAAiB,EAAE;UAC9CF,SAAS,CAACJ,YAAY,GAAGM,iBAAiB;UAC1CF,SAAS,CAACG,MAAM,GAAGN,WAAW;UAE9B,IAAI,CAACf,cAAc,CAACsB,IAAI,CAACJ,SAAS,CAAC;UACnCA,SAAS,CAACK,YAAY,GAAG,IAAI;;;MAIjCR,WAAW,CAACT,SAAS,GAAG,IAAI;IAC9B,CAAC;IAED,KAAAC,gBAAgB,GAAIQ,WAAiB,IAAI;MACvC,IAAIC,mBAAmB,GAAG,IAAI,CAACQ,6BAA6B,CAACT,WAAW,CAAC;MAEzE,KAAK,IAAI;QAAEH,IAAI,EAAEM,SAAS;QAAEC;MAAgB,CAAE,IAAIH,mBAAmB,EAAE;QACrE,IAAII,iBAAiB,GAAGL,WAAW,CAACrB,mBAAmB,GAAGyB,gBAAgB;QAE1E,IAAID,SAAS,CAACxB,mBAAmB,GAAG0B,iBAAiB,EAAE;UACrDF,SAAS,CAACxB,mBAAmB,GAAG0B,iBAAiB;UACjDF,SAAS,CAACG,MAAM,GAAGN,WAAW;UAE9B,IAAI,CAACnB,qBAAqB,CAAC0B,IAAI,CAACJ,SAAS,CAAC;UAC1CA,SAAS,CAACK,YAAY,GAAG,IAAI;;;MAIjCR,WAAW,CAACvB,gBAAgB,GAAG,IAAI;IACrC,CAAC;IAED,KAAAgC,6BAA6B,GAAIZ,IAAU,IAAI;MAC7C,IAAIa,cAAc,GAAGb,IAAI,CAACc,UAAU;MAEpC,OAAO,CAAC,GAAGD,cAAc,CAACE,MAAM,CAAET,SAAS,IAAK,CAACA,SAAS,CAACN,IAAI,CAACgB,SAAS,IAAI,CAACV,SAAS,CAACN,IAAI,CAACpB,gBAAgB,CAAC,CAAC;IACjH,CAAC;IAEQ,KAAAqC,WAAW,GAAG,MAA2C;MAChE,IAAI,IAAI,CAACxB,WAAW,IAAI,IAAI,CAACZ,UAAU,EAAE;QACvC,OAAO;UAAEqC,MAAM,EAAE,IAAI;UAAEC,MAAM,EAAE;QAAa,CAAE;OAC/C,MAAM,IAAI,IAAI,CAAC/B,cAAc,CAACgC,MAAM,IAAI,CAAC,IACvC,IAAI,CAACpC,qBAAqB,CAACoC,MAAM,IAAI,CAAC,EAAE;QACzC,OAAO;UAAEF,MAAM,EAAE,IAAI;UAAEC,MAAM,EAAE;QAAa,CAAE;OAC/C,MAAM;QACL,OAAO;UAAED,MAAM,EAAE;QAAK,CAAE;;IAE5B,CAAC;IAEQ,KAAAG,SAAS,GAAIC,WAAkB,IAAY;MAClD,IAAIC,SAAS,GAAG,EAAE;MAElB,IAAIvB,IAAI,GAAG,IAAI,CAACP,WAAW;MAC3B,OAAOO,IAAI,CAACS,MAAM,IAAI,IAAI,CAAC9B,YAAY,EAAE;QACvC4C,SAAS,CAACb,IAAI,CAACV,IAAI,CAAC;QACpBA,IAAI,GAAGA,IAAI,CAACS,MAAM;;MAGpBT,IAAI,GAAG,IAAI,CAACjB,kBAAkB;MAC9B,OAAOiB,IAAI,CAACS,MAAM,IAAI,IAAI,CAAC5B,UAAU,EAAE;QACrC0C,SAAS,CAACb,IAAI,CAACV,IAAI,CAAC;QACpBA,IAAI,GAAGA,IAAI,CAACS,MAAM;;MAGpB,OAAOc,SAAS;IAClB,CAAC;;;SAxHUjD,oBAAqB;;;;+GAArBA,MAAoB,IAAAkD,CAAA,IAApBlD,MAAoB;EAAA;AAAA;;SAApBA,MAAoB;EAAAmD,OAAA,EAApBnD,MAAoB,CAAAoD,IAAA;EAAAC,UAAA,EAHnB;AAAM"},"metadata":{},"sourceType":"module","externalDependencies":[]}